<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alexxigang</title>
  
  <subtitle>专注技术</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-25T12:42:42.349Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Alex</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>topic-26-27</title>
    <link href="http://yoursite.com/2020/02/25/topic-26-27/"/>
    <id>http://yoursite.com/2020/02/25/topic-26-27/</id>
    <published>2020-02-25T12:18:22.000Z</published>
    <updated>2020-02-25T12:42:42.349Z</updated>
    
    <content type="html"><![CDATA[<h2 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26-树的子结构"></a>26-树的子结构</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>输入两颗二叉树A，B，判断B是不是A的子结构。（PS：我们约定空树不是任意一个树的子结构）</p></blockquote><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>查找树A中是否存在和树B结构一样的子树，我们可以分为两步：第一步在树A中找到和B的根结点的值一样的结点R，第二步再判断树A中以R为根节点的子树是不是包含和树B一样的结构。这里使用递归的方法即可。</p><blockquote><p>代码如下：   </p></blockquote><pre><code class="lang-c++">/*struct TreeNode {    int val;    struct TreeNode *left;    struct TreeNode *right;    TreeNode(int x) :            val(x), left(NULL), right(NULL) {    }};*/class Solution {public:    bool HasSubtree(TreeNode* pRoot1, TreeNode* pRoot2)    {        bool result = false;        if(pRoot1 != NULL &amp;&amp; pRoot2 != NULL){            if(pRoot1-&gt;val == pRoot2-&gt;val){            result = DoesTree1HasTree2(pRoot1, pRoot2);        }            if(!result){                result = HasSubtree(pRoot1-&gt;left, pRoot2);            }            if(!result){                result = HasSubtree(pRoot1-&gt;right, pRoot2);            }        }        return result;    }private:    bool DoesTree1HasTree2(TreeNode* pRoot1, TreeNode* pRoot2){        if(pRoot2 == NULL){            return true;        }        if(pRoot1 == NULL){            return false;        }        if(pRoot1-&gt;val != pRoot2-&gt;val){            return false;        }        return DoesTree1HasTree2(pRoot1-&gt;left, pRoot2-&gt;left) &amp;&amp; DoesTree1HasTree2(pRoot1-&gt;right, pRoot2-&gt;right);    }};</code></pre><h2 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27-二叉树的镜像"></a>27-二叉树的镜像</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p></blockquote><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>先交换根节点的两个子结点之后，我们注意到值为10、6的结点的子结点仍然保持不变，因此我们还需要交换这两个结点的左右子结点。做完这两次交换之后，我们已经遍历完所有的非叶结点。此时变换之后的树刚好就是原始树的镜像。</p><blockquote><p>代码如下：   </p></blockquote><pre><code class="lang-c++">/*struct TreeNode {    int val;    struct TreeNode *left;    struct TreeNode *right;    TreeNode(int x) :            val(x), left(NULL), right(NULL) {    }};*/class Solution {public:    void Mirror(TreeNode *pRoot) {        if((pRoot == NULL) || (pRoot-&gt;left == NULL &amp;&amp; pRoot-&gt;right == NULL)){            return;        }        //交换根节点的左右结点        TreeNode *pTemp = pRoot-&gt;left;        pRoot-&gt;left = pRoot-&gt;right;        pRoot-&gt;right = pTemp;        //递归左子树        if(pRoot-&gt;left){            Mirror(pRoot-&gt;left);        }        //递归右子树        if(pRoot-&gt;right){            Mirror(pRoot-&gt;right);        }    }};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;26-树的子结构&quot;&gt;&lt;a href=&quot;#26-树的子结构&quot; class=&quot;headerlink&quot; title=&quot;26-树的子结构&quot;&gt;&lt;/a&gt;26-树的子结构&lt;/h2&gt;&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="刷题" scheme="http://yoursite.com/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020/02/24/topic-24-25/"/>
    <id>http://yoursite.com/2020/02/24/topic-24-25/</id>
    <published>2020-02-24T12:18:54.842Z</published>
    <updated>2020-02-24T12:25:35.553Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: topic-24-25<br>date: 2020-02-24 20:18:54<br>tags:</p><ul><li>刷题<br>categories:</li><li>剑指offer</li></ul><hr><h2 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24-反转链表"></a>24-反转链表</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>输入一个链表，反转链表后，输出链表的所有元素。</p></blockquote><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>使用三个指针，分别指向当前遍历到的结点、它的前一个结点以及后一个结点。在遍历的时候，做当前结点的尾结点和前一个结点的替换。</p><blockquote><p>代码如下：   </p></blockquote><pre><code class="lang-c++">/*struct ListNode {    int val;    struct ListNode *next;    ListNode(int x) :            val(x), next(NULL) {    }};*/class Solution {public:    ListNode* ReverseList(ListNode* pHead) {        ListNode* pReversedHead = NULL;        ListNode* pNode = pHead;        ListNode* pPrev = NULL;        while(pNode != NULL){            ListNode* pNext = pNode-&gt;next;            if(pNext == NULL){                pReversedHead = pNode;            }            pNode-&gt;next = pPrev;            pPrev = pNode;            pNode = pNext;        }        return pReversedHead;    }};</code></pre><h2 id="25-合并两个排序的链表"><a href="#25-合并两个排序的链表" class="headerlink" title="25-合并两个排序的链表"></a>25-合并两个排序的链表</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p></blockquote><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>先判断输入的链表是否为空的指针。如果第一个链表为空，则直接返回第二个链表；如果第二个链表为空，则直接返回第一个链表。如果两个链表都是空链表，合并的结果是得到一个空链表。<br>两个链表都是排序好的，我们只需要从头遍历链表，判断当前指针，哪个链表中的值小，即赋给合并链表指针即可。使用递归就可以轻松实现。</p><blockquote><p>代码如下：   </p></blockquote><pre><code class="lang-c++">/*struct ListNode {    int val;    struct ListNode *next;    ListNode(int x) :            val(x), next(NULL) {    }};*/class Solution {public:    ListNode* Merge(ListNode* pHead1, ListNode* pHead2)    {        //判断指针是否为空        if(pHead1 == NULL){            return pHead2;        }        else if(pHead2 == NULL){            return pHead1;        }        ListNode* pMergedHead = NULL;        if(pHead1-&gt;val &lt; pHead2-&gt;val){            pMergedHead = pHead1;               pMergedHead-&gt;next = Merge(pHead1-&gt;next, pHead2);        }        else{            pMergedHead = pHead2;               pMergedHead-&gt;next = Merge(pHead1, pHead2-&gt;next);        }        return pMergedHead;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: topic-24-25&lt;br&gt;date: 2020-02-24 20:18:54&lt;br&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;刷题&lt;br&gt;categories:&lt;/li&gt;
&lt;li&gt;剑指offer&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;24-
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020/02/23/topic-21-22/"/>
    <id>http://yoursite.com/2020/02/23/topic-21-22/</id>
    <published>2020-02-23T12:39:41.365Z</published>
    <updated>2020-02-23T12:46:22.568Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: topic-21-22<br>date: 2020-02-23 20:39:41<br>tags:</p><ul><li>刷题<br>categories:</li><li>剑指offer</li></ul><hr><h2 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21-调整数组顺序使奇数位于偶数前面"></a>21-调整数组顺序使奇数位于偶数前面</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。  </p></blockquote><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>创建双向队列，遍历数组，奇数前插入，偶数后插入。最后使用assign方法实现不同容器但相容的类型赋值。</p><blockquote><p>代码如下：  </p></blockquote><pre><code class="lang-c++">class Solution {public:    void reOrderArray(vector&lt;int&gt; &amp;array) {        deque&lt;int&gt; result;        int num = array.size();        for(int i = 0; i &lt; num; i++){            if(array[num - i - 1] % 2 == 1){                result.push_front(array[num - i - 1]);            }            if(array[i] % 2 == 0){                result.push_back(array[i]);            }        }        array.assign(result.begin(),result.end());    }};</code></pre><h2 id="22-链表中倒数第k个结点"><a href="#22-链表中倒数第k个结点" class="headerlink" title="22-链表中倒数第k个结点"></a>22-链表中倒数第k个结点</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>输入一个链表，输出该链表中倒数第k个结点。  </p></blockquote><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>我们可以定义两个指针。第一个指针从链表的头指针开始遍历向前走k-1，第二个指针保持不动；从第k步开始，第二个指针也开始从链表的头指针开始遍历。由于两个指针的距离保持在k-1，当第一个（走在前面的）指针到达链表的尾结点时，第二个指针（走在后面的）指针正好是倒数第k个结点。</p><blockquote><p>代码如下： </p></blockquote><pre><code class="lang-c++">/*struct ListNode {    int val;    struct ListNode *next;    ListNode(int x) :            val(x), next(NULL) {    }};*/class Solution {public:    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) {        if(pListHead == NULL || k == 0){            return NULL;        }        ListNode *pAhead = pListHead;        ListNode *pBehind = pListHead;        for(unsigned int i = 0; i &lt; k - 1; i++){            if(pAhead-&gt;next != NULL){                pAhead = pAhead-&gt;next;            }            else{                return NULL;            }        }        while(pAhead-&gt;next != NULL){            pAhead = pAhead-&gt;next;            pBehind = pBehind-&gt;next;        }        return pBehind;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: topic-21-22&lt;br&gt;date: 2020-02-23 20:39:41&lt;br&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;刷题&lt;br&gt;categories:&lt;/li&gt;
&lt;li&gt;剑指offer&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;21-
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>topic-19-20</title>
    <link href="http://yoursite.com/2020/02/22/topic-19-20/"/>
    <id>http://yoursite.com/2020/02/22/topic-19-20/</id>
    <published>2020-02-22T11:46:04.000Z</published>
    <updated>2020-02-22T12:21:32.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="19-正则表达式匹配"><a href="#19-正则表达式匹配" class="headerlink" title="19-正则表达式匹配"></a>19-正则表达式匹配</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>请实现一个函数用来匹配包括’.’和’<em>‘的正则表达式。模式中的字符’.’表示任意一个字符，而’</em>‘表示它前面的字符可以出现任意次（包含0次）。 在本题中，匹配是指字符串的所有字符匹配整个模式。例如，字符串”aaa”与模式”a.a”和”ab<em>ac</em>a”匹配，但是与”aa.a”和”ab*a”均不匹配。</p></blockquote><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>分两种情况来看：</p><ul><li><p>模式串的下一个字符不是’*’，也就是上面说的只有字符’.’的情况。<br>如果字符串中的第一个字符和模式串中的第一个字符相匹配，那么字符串的模式串都向后移动一个字符，然后匹配剩余的字符串和模式串。如果字符串中的第一个字符和模式中的第一个字符不相匹配，则直接返回false。</p></li><li><p>模式串的下一个字符是’*’，此时就要复杂一些。<br>因为可能有多种不同的匹配方式。</p><ul><li><p>选择一：无论字符串和模式串当前字符相不相等，我们都将模式串后移两个字符，相当于把模式串中的当前字符和’<em>‘忽略掉，因为’</em>‘可以匹配任意次的字符，所以出现0次也可以。</p></li><li><p>选择二：如果字符串和模式串当前字符相等，则字符串向后移动一个字符。而模式串此时有两个选择：</p><ul><li><p>1、我们可以在模式串向后移动两个字符，继续匹配；</p></li><li><p>2、也可以保持模式串不变，这样相当于用字符’<em>‘继续匹配字符串，也就是模式串中的字符’</em>‘匹配字符串中的字符多个的情况。</p></li></ul></li></ul></li></ul><p>除此之外，还要注意对空指针的处理。</p><blockquote><p>代码如下： </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 指针为空，返回false</span></span><br><span class="line">        <span class="keyword">if</span>(str == <span class="literal">NULL</span> || pattern == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matchCore(str, pattern);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">matchCore</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">char</span>* pattern)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 字符串和模式串都运行到了结尾，返回true</span></span><br><span class="line">        <span class="keyword">if</span>(*str == <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 字符串没有到结尾，模式串到了，则返回false</span></span><br><span class="line">        <span class="comment">// 模式串没有到结尾，字符串到了，则根据后续判断进行，需要对'*'做处理</span></span><br><span class="line">        <span class="keyword">if</span>((*str != <span class="string">'\0'</span> &amp;&amp; *pattern == <span class="string">'\0'</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果模式串的下一个字符是'*'，则进入状态机的匹配</span></span><br><span class="line">        <span class="keyword">if</span>(*(pattern + <span class="number">1</span>) == <span class="string">'*'</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果字符串和模式串相等，或者模式串是'.'，并且字符串没有到结尾，则继续匹配</span></span><br><span class="line">            <span class="keyword">if</span>(*str == *pattern || (*pattern == <span class="string">'.'</span> &amp;&amp; *str != <span class="string">'\0'</span>))&#123;</span><br><span class="line">                <span class="comment">// 进入下一个状态，就是匹配到了一个</span></span><br><span class="line">                <span class="keyword">return</span> matchCore(str + <span class="number">1</span>, pattern + <span class="number">2</span>) ||</span><br><span class="line">                    <span class="comment">// 保持当前状态，就是继续那这个'*'去匹配</span></span><br><span class="line">                    matchCore(str + <span class="number">1</span>, pattern) ||</span><br><span class="line">                    <span class="comment">// 跳过这个'*'</span></span><br><span class="line">                    matchCore(str, pattern + <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果字符串和模式串不相等，则跳过当前模式串的字符和'*'，进入新一轮的匹配</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 跳过这个'*'</span></span><br><span class="line">                <span class="keyword">return</span> matchCore(str, pattern + <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果字符串和模式串相等，或者模式串是'.'，并且字符串没有到结尾，则继续匹配</span></span><br><span class="line">        <span class="keyword">if</span>(*str == *pattern || (*pattern == <span class="string">'.'</span> &amp;&amp; *str != <span class="string">'\0'</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> matchCore(str + <span class="number">1</span>, pattern + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="20-表示数值的字符串"><a href="#20-表示数值的字符串" class="headerlink" title="20-表示数值的字符串"></a>20-表示数值的字符串</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>请实现一个函数用来判断字符串是否表示数值（包括整数和小数）。例如，字符串”+100”,”5e2”,”-123”,”3.1416”和”-1E-16”都表示数值。 但是”12e”,”1a3.14”,”1.2.3”,”+-5”和”12e+4.3”都不是。  </p></blockquote><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>表示数值的字符串遵循如下模式：</p><pre><code>[sign]integral-digits[.[fractional-digits]][e|E[sign]exponential-digits]</code></pre><p>其中，(‘[‘和’]’之间的为可有可无的部分)。</p><p>在数值之前可能有一个表示正负的’+’或者’-‘。接下来是若干个0到9的数位表示数值的整数部分（在某些小数里可能没有数值的整数部分）。如果数值是一个小数，那么在小数后面可能会有若干个0到9的数位表示数值的小数部分。如果数值用科学记数法表示，接下来是一个’e’或者’E’，以及紧跟着的一个整数（可以有正负号）表示指数。</p><p>判断一个字符串是否符合上述模式时，首先看第一个字符是不是正负号。如果是，在字符串上移动一个字符，继续扫描剩余的字符串中0到9的数位。如果是一个小数，则将遇到小数点。另外，如果是用科学记数法表示的数值，在整数或者小数的后面还有可能遇到’e’或者’E’。</p><blockquote><p>代码如下：  </p></blockquote><pre><code class="lang-c++">class Solution {public:    // 数字的格式可以用A[.[B]][e|EC]或者.B[e|EC]表示，    // 其中A和C都是整数（可以有正负号，也可以没有）    // 而B是一个无符号整数    bool isNumeric(char* string)    {        // 非法输入处理        if(string == NULL || *string == &#39;\0&#39;){            return false;        }        // 正负号判断        if(*string == &#39;+&#39; || *string == &#39;-&#39;){            ++string;        }        bool numeric = true;        scanDigits(&amp;string);        if(*string != &#39;\0&#39;){            // 小数判断            if(*string == &#39;.&#39;){                ++string;                scanDigits(&amp;string);                if(*string == &#39;e&#39; || *string == &#39;E&#39;){                    numeric = isExponential(&amp;string);                }            }            // 整数判断            else if(*string == &#39;e&#39; || *string == &#39;E&#39;){                numeric = isExponential(&amp;string);            }            else{                numeric = false;            }        }        return numeric &amp;&amp; *string == &#39;\0&#39;;    }private:    // 扫描数字，对于合法数字，直接跳过    void scanDigits(char** string){        while(**string != &#39;\0&#39; &amp;&amp; **string &gt;= &#39;0&#39; &amp;&amp; **string &lt;= &#39;9&#39;){            ++(*string);        }    }    // 用来潘达un科学计数法表示的数值的结尾部分是否合法    bool isExponential(char** string){        ++(*string);        if(**string == &#39;+&#39; || **string == &#39;-&#39;){            ++(*string);        }        if(**string == &#39;\0&#39;){            return false;        }        scanDigits(string);        // 判断是否结尾，如果没有结尾，说明还有其他非法字符串        return (**string == &#39;\0&#39;) ? true : false;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;19-正则表达式匹配&quot;&gt;&lt;a href=&quot;#19-正则表达式匹配&quot; class=&quot;headerlink&quot; title=&quot;19-正则表达式匹配&quot;&gt;&lt;/a&gt;19-正则表达式匹配&lt;/h2&gt;&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="刷题" scheme="http://yoursite.com/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>topic-17-18</title>
    <link href="http://yoursite.com/2020/02/21/topic-17-18/"/>
    <id>http://yoursite.com/2020/02/21/topic-17-18/</id>
    <published>2020-02-21T12:50:04.000Z</published>
    <updated>2020-02-21T13:02:23.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="17-打印从1到最大的n位数"><a href="#17-打印从1到最大的n位数" class="headerlink" title="17-打印从1到最大的n位数"></a>17-打印从1到最大的n位数</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p></blockquote><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>利用c++的generate解决</p><blockquote><p>代码如下： </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printNumbers(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">int</span> max_num = <span class="built_in">pow</span>(<span class="number">10</span>, n) - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(max_num);</span><br><span class="line">    <span class="built_in">std</span>::generate(v.begin(), v.end(), [n=<span class="number">1</span>]()<span class="keyword">mutable</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n++;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="18-删除链表的节点"><a href="#18-删除链表的节点" class="headerlink" title="18-删除链表的节点"></a>18-删除链表的节点</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。</p></blockquote><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>构建头部 dummy 节点，后面的操作就可以转化为一般化得链表节点移除问题</p><blockquote><p>代码如下：  </p></blockquote><pre><code class="lang-c++">class Solution {public:    ListNode* deleteNode(ListNode* head, int val) {        ListNode* dummy = new ListNode(0);        dummy -&gt; next = head;        ListNode* prev = dummy;        while(prev &amp;&amp; prev -&gt; next) {            if(prev -&gt; next -&gt; val == val) {                prev -&gt; next = prev -&gt; next -&gt; next;            }            prev = prev -&gt; next;        }        return dummy -&gt; next;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;17-打印从1到最大的n位数&quot;&gt;&lt;a href=&quot;#17-打印从1到最大的n位数&quot; class=&quot;headerlink&quot; title=&quot;17-打印从1到最大的n位数&quot;&gt;&lt;/a&gt;17-打印从1到最大的n位数&lt;/h2&gt;&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="刷题" scheme="http://yoursite.com/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>topic-14-15-16</title>
    <link href="http://yoursite.com/2020/02/20/topic-14-15-16/"/>
    <id>http://yoursite.com/2020/02/20/topic-14-15-16/</id>
    <published>2020-02-20T13:32:10.000Z</published>
    <updated>2020-02-20T13:38:46.855Z</updated>
    
    <content type="html"><![CDATA[<h2 id="14-剪绳子"><a href="#14-剪绳子" class="headerlink" title="14-剪绳子"></a>14-剪绳子</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为k[0],k[1],…,k[m]。请问k[0]xk[1]x…xk[m]可能的最大乘积是多少？例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p></blockquote><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>利用动态规划，需要O(n^2)时间和O(n)空间，也就是利用一个表，储存长度为1~n绳子的最大乘积。</p><blockquote><p>代码如下： </p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">cutRope</span><span class="params">(self, number)</span>:</span></span><br><span class="line">     <span class="comment"># write code here</span></span><br><span class="line">     <span class="keyword">if</span> number &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">     <span class="keyword">if</span> number == <span class="number">2</span>:<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">     <span class="keyword">if</span> number == <span class="number">3</span>:<span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">     products = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>, number+<span class="number">1</span>, <span class="number">1</span>):</span><br><span class="line">         product = <span class="number">0</span></span><br><span class="line">         <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">4</span>//<span class="number">2</span>+<span class="number">1</span>,<span class="number">1</span>):</span><br><span class="line">             res = products[j]* products[i-j]</span><br><span class="line">             product = max(res,product)</span><br><span class="line">             products.append(product)</span><br><span class="line">     <span class="keyword">return</span>  products[<span class="number">-1</span>]</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"><span class="comment">## 15-二进制中一的个数</span></span><br><span class="line"><span class="comment">### 题目描述  </span></span><br><span class="line">&gt;输入一个整数，输出该数二进制表示中<span class="number">1</span>的个数。其中负数用补码表示。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 解法  </span></span><br><span class="line">如果一个整数不为<span class="number">0</span>，那么这个整数至少有一位是<span class="number">1</span>。如果我们把这个整数减<span class="number">1</span>，那么原来处在整数最右边的<span class="number">1</span>就会变为<span class="number">0</span>，原来在<span class="number">1</span>后面的所有的<span class="number">0</span>都会变成<span class="number">1</span>(如果最右边的<span class="number">1</span>后面还有<span class="number">0</span>的话)。其余所有位将不会受到影响。</span><br><span class="line"></span><br><span class="line">举个例子：一个二进制数<span class="number">1100</span>，从右边数起第三位是处于最右边的一个<span class="number">1</span>。减去<span class="number">1</span>后，第三位变成<span class="number">0</span>，它后面的两位<span class="number">0</span>变成了<span class="number">1</span>，而前面的<span class="number">1</span>保持不变，因此得到的结果是<span class="number">1011.</span>我们发现减<span class="number">1</span>的结果是把最右边的一个<span class="number">1</span>开始的所有位都取反了。这个时候如果我们再把原来的整数和减去<span class="number">1</span>之后的结果做与运算，从原来整数最右边一个<span class="number">1</span>那一位开始所有位都会变成<span class="number">0</span>。如<span class="number">1100</span>&amp;<span class="number">1011</span>=<span class="number">1000.</span>也就是说，把一个整数减去<span class="number">1</span>，再和原整数做与运算，会把该整数最右边一个<span class="number">1</span>变成<span class="number">0.</span>那么一个整数的二进制有多少个<span class="number">1</span>，就可以进行多少次这样的操作。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&gt; 代码如下：  </span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">     int  NumberOf1(int n) &#123;</span><br><span class="line">         int count = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">while</span>(n)&#123;</span><br><span class="line">             ++count;</span><br><span class="line">             n = (n - <span class="number">1</span>) &amp; n;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> count;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 16-数值的整数次方</span></span><br><span class="line"><span class="comment">### 题目描述  </span></span><br><span class="line">&gt;给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。保证base和exponent不同时为<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 解法  </span></span><br><span class="line">当指数为负数的时候，可以先对指数求绝对值，然后算出次方的结果之后再取倒数。如果底数为<span class="number">0</span>，则直接返回<span class="number">0</span>。此时的次方在数学上是没有意义的。</span><br><span class="line">除此之外，我们要注意：由于计算机表示小数（包括float和double型小数）都有误差，我们不能直接用等号（==）判断两个小数是否相等。如果两个小数的差的绝对值很小，比如小于<span class="number">0.0000001</span>，就可以认为它们相等。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&gt; 代码如下：  </span><br><span class="line"></span><br><span class="line">```c++</span><br><span class="line">class Solution &#123;</span><br><span class="line">    /*</span><br><span class="line">    由于计算机表示小数（包括float和double型小数）都有误差，我们不能直接用等号</span><br><span class="line">    （==）判断两个小数是否相等。</span><br><span class="line">    如果两个小数的差的绝对值很小，比如小于<span class="number">0.0000001</span>，就可以认为它们相等。</span><br><span class="line">    */</span><br><span class="line">public:</span><br><span class="line">    double Power(double base, int exponent) &#123;</span><br><span class="line">        <span class="keyword">if</span>(equal(base,<span class="number">0.0</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        unsigned int absexponent=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(exponent&lt;<span class="number">0.0</span>)&#123;</span><br><span class="line">            absexponent=(unsigned int)(-exponent);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            absexponent=(unsigned int)(exponent);</span><br><span class="line">        &#125;</span><br><span class="line">        double result=PowerWithUnsignedExponent(base,absexponent);</span><br><span class="line">        <span class="keyword">if</span>(exponent&lt;<span class="number">0.0</span>)&#123;</span><br><span class="line">            result=<span class="number">1.0</span>/result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    bool equal(double num1,double num2)&#123;</span><br><span class="line">        <span class="keyword">if</span>((num1-num2)&gt;<span class="number">-0.0000001</span>&amp;&amp;(num1-num2)&lt;<span class="number">0.0000001</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> true;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> false;</span><br><span class="line">    &#125;</span><br><span class="line">    double PowerWithUnsignedExponent(double base,unsigned int exponent)&#123;</span><br><span class="line">       <span class="keyword">if</span>(exponent==<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> base;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">if</span>(exponent==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        double result=PowerWithUnsignedExponent(base,exponent&gt;&gt;<span class="number">1</span>);</span><br><span class="line">        result*=result;</span><br><span class="line">        <span class="keyword">if</span>((exponent&amp;<span class="number">0x1</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">            result*=base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;14-剪绳子&quot;&gt;&lt;a href=&quot;#14-剪绳子&quot; class=&quot;headerlink&quot; title=&quot;14-剪绳子&quot;&gt;&lt;/a&gt;14-剪绳子&lt;/h2&gt;&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="刷题" scheme="http://yoursite.com/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>topic-13-14</title>
    <link href="http://yoursite.com/2020/02/19/topic-13-14/"/>
    <id>http://yoursite.com/2020/02/19/topic-13-14/</id>
    <published>2020-02-19T13:22:15.000Z</published>
    <updated>2020-02-20T13:38:44.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="13-机器人的运动范围"><a href="#13-机器人的运动范围" class="headerlink" title="13-机器人的运动范围"></a>13-机器人的运动范围</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p></blockquote><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>和矩阵中的路径十分相似，只不过这次的限制条件变成了坐标位数之和。对于求坐标位数之和，我们单独用一个函数实现，然后套入上一道题的代码中即可。</p><blockquote><p>代码如下： </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(threshold &lt; <span class="number">1</span> || rows &lt; <span class="number">1</span> || cols &lt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span>* visited = <span class="keyword">new</span> <span class="keyword">bool</span>[rows*cols];</span><br><span class="line">        <span class="built_in">memset</span>(visited, <span class="number">0</span>, rows*cols);</span><br><span class="line">        count = movingCountCore(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, visited);</span><br><span class="line">        <span class="keyword">delete</span>[] visited;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCountCore</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">bool</span>* visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(row &gt;= <span class="number">0</span> &amp;&amp; row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; cols &amp;&amp; getDigitSum(row)+getDigitSum(col) &lt;= threshold &amp;&amp; !visited[row*cols+col])&#123;</span><br><span class="line">            visited[row*cols+col] = <span class="literal">true</span>;</span><br><span class="line">            count = <span class="number">1</span> + movingCountCore(threshold, rows, cols, row+<span class="number">1</span>, col, visited)</span><br><span class="line">                + movingCountCore(threshold, rows, cols, row<span class="number">-1</span>, col, visited)</span><br><span class="line">                + movingCountCore(threshold, rows, cols, row, col+<span class="number">1</span>, visited)</span><br><span class="line">                + movingCountCore(threshold, rows, cols, row, col<span class="number">-1</span>, visited);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getDigitSum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num)&#123;</span><br><span class="line">            sum += num % <span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## <span class="number">14</span>-剪绳子</span><br><span class="line">### 题目描述  </span><br><span class="line">&gt;给你一根长度为n的绳子，请把绳子剪成整数长的m段（m、n都是整数，n&gt;<span class="number">1</span>并且m&gt;<span class="number">1</span>），每段绳子的长度记为k[<span class="number">0</span>],k[<span class="number">1</span>],...,k[m]。请问k[<span class="number">0</span>]xk[<span class="number">1</span>]x...xk[m]可能的最大乘积是多少？例如，当绳子的长度是<span class="number">8</span>时，我们把它剪成长度分别为<span class="number">2</span>、<span class="number">3</span>、<span class="number">3</span>的三段，此时得到的最大乘积是<span class="number">18</span>。</span><br><span class="line"></span><br><span class="line">### 解法  </span><br><span class="line">利用动态规划，需要O(n^<span class="number">2</span>)时间和O(n)空间，也就是利用一个表，储存长度为<span class="number">1</span>~n绳子的最大乘积。</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&gt; 代码如下： </span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"> def cutRope(self, number):</span><br><span class="line">     <span class="meta"># write code here</span></span><br><span class="line">     <span class="keyword">if</span> number &lt; <span class="number">2</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">     <span class="keyword">if</span> number == <span class="number">2</span>:<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">     <span class="keyword">if</span> number == <span class="number">3</span>:<span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">     products = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">     <span class="keyword">for</span> i in range(<span class="number">4</span>, number+<span class="number">1</span>, <span class="number">1</span>):</span><br><span class="line">         product = <span class="number">0</span></span><br><span class="line">         <span class="keyword">for</span> j in range(<span class="number">1</span>,<span class="number">4</span><span class="comment">//2+1,1):</span></span><br><span class="line">             res = products[j]* products[i-j]</span><br><span class="line">             product = max(res,product)</span><br><span class="line">             products.append(product)</span><br><span class="line">     <span class="keyword">return</span>  products[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;13-机器人的运动范围&quot;&gt;&lt;a href=&quot;#13-机器人的运动范围&quot; class=&quot;headerlink&quot; title=&quot;13-机器人的运动范围&quot;&gt;&lt;/a&gt;13-机器人的运动范围&lt;/h2&gt;&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="刷题" scheme="http://yoursite.com/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020/02/18/topic-11-12/"/>
    <id>http://yoursite.com/2020/02/18/topic-11-12/</id>
    <published>2020-02-18T12:14:40.173Z</published>
    <updated>2020-02-18T12:31:26.718Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: topic-11-12<br>date: 2020-02-18 20:14:40<br>tags:</p><ul><li>刷题<br>categories:</li><li>剑指offer</li></ul><hr><h2 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11-旋转数组的最小数字"></a>11-旋转数组的最小数字</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br>例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。<br>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p></blockquote><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><ul><li>我们可以找到数组中间的元素。如果中间元素位于前面的递增子数组，那么它应该大于或者等于第一个指针指向的元素。此时最小元素应该位于该中间元素之后，然后我们把第一个指针指向该中间元素，移动之后第一个指针仍然位于前面的递增子数组中。</li><li>同样，如果中间元素位于后面的递增子数组，那么它应该小于或者等于第二个指针指向的元素。此时最小元素应该位于该中间元素之前，然后我们把第二个指针指向该中间元素，移动之后第二个指针仍然位于后面的递增子数组中。</li><li><p>第一个指针总是指向前面递增数组的元素，第二个指针总是指向后面递增数组的元素。最终它们会指向两个相邻的元素，而第二个指针指向的刚好是最小的元素，这就是循环结束的条件。  </p><blockquote><p>特殊情况：</p></blockquote></li><li><p>如果把排序数组的0个元素搬到最后面，这仍然是旋转数组，我们的代码需要支持这种情况。如果发现数组中的一个数字小于最后一个数字，就可以直接返回第一个数字了。</p></li><li>下面这种情况，即第一个指针指向的数字、第二个指针指向的数字和中间的数字三者相等，我们无法判断中间的数字1是数以前面的递增子数组还是后面的递增子数组。正样的话，我们只能进行顺序查找。  <blockquote><p>代码如下： </p></blockquote></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len=rotateArray.size();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=len<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> mid=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(rotateArray[left]&gt;=rotateArray[right])&#123;</span><br><span class="line">            <span class="keyword">if</span>((right-left)==<span class="number">1</span>)&#123;</span><br><span class="line">                mid=right;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(rotateArray[right]==rotateArray[left]&amp;&amp;rotateArray[mid]==rotateArray[right])&#123;</span><br><span class="line">                <span class="keyword">return</span> MinInOrder(rotateArray,left,right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rotateArray[mid]&gt;=rotateArray[left])&#123;</span><br><span class="line">                left=mid;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right=mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rotateArray[mid];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">MinInOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=num[left];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;right;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(num[i]&lt;result)&#123;</span><br><span class="line">                result=num[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="12-矩阵中的路径"><a href="#12-矩阵中的路径" class="headerlink" title="12-矩阵中的路径"></a>12-矩阵中的路径</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。</p></blockquote><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>当矩阵坐标为（row，col）的格子和路径字符串中下标为pathLength的字符一样时，从4个相邻的格子（row，col-1）、（row-1，col）、（row，col+1）以及（row+1，col）中去定位路径字符串中下标为pathLength+1的字符。如果4个相邻的格子都没有匹配字符串中下标为pathLength+1的字符，表明当前路径字符串中下标为pathLength的字符在矩阵中的定位不正确，我们需要回到前一个字符串（pathLength-1），然后重新定位。一直重复这个过程，直到路径字符串上所有字符都在矩阵中找到格式的位置（此时str[pathLength] == ‘\0’）。</p><blockquote><p>代码如下： </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>* matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>* str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix==<span class="literal">NULL</span>||rows&lt;<span class="number">1</span>||cols&lt;<span class="number">1</span>||str==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span>* visited=<span class="keyword">new</span> <span class="keyword">bool</span>[rows*cols];</span><br><span class="line">        <span class="built_in">memset</span>(visited,<span class="number">0</span>,rows*cols);</span><br><span class="line">        <span class="keyword">int</span> pathLength=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>;row&lt;rows;row++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;cols;col++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(hasPathCore(matrix,rows,cols,row,col,str,pathLength,visited))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] visited;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasPathCore</span><span class="params">(<span class="keyword">char</span>* matrix,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="keyword">char</span>* str,<span class="keyword">int</span>&amp; pathLength,<span class="keyword">bool</span>* visited)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[pathLength]==<span class="string">'\0'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">bool</span> hasPath=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(row&gt;=<span class="number">0</span>&amp;&amp;col&gt;=<span class="number">0</span>&amp;&amp;row&lt;rows&amp;&amp;col&lt;cols&amp;&amp;matrix[row*cols+col]==str[pathLength]&amp;&amp;(!visited[row*cols+col]))&#123;</span><br><span class="line">            visited[row*cols+col]=<span class="literal">true</span>;</span><br><span class="line">            pathLength++;</span><br><span class="line">            hasPath=hasPathCore(matrix,rows,cols,row+<span class="number">1</span>,col,str,pathLength,visited)</span><br><span class="line">                ||hasPathCore(matrix,rows,cols,row<span class="number">-1</span>,col,str,pathLength,visited)</span><br><span class="line">                ||hasPathCore(matrix,rows,cols,row,col<span class="number">-1</span>,str,pathLength,visited)</span><br><span class="line">                ||hasPathCore(matrix,rows,cols,row,col+<span class="number">1</span>,str,pathLength,visited);</span><br><span class="line">            <span class="keyword">if</span>(!hasPath)&#123;</span><br><span class="line">                pathLength--;</span><br><span class="line">                visited[row*cols+col]=<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> hasPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: topic-11-12&lt;br&gt;date: 2020-02-18 20:14:40&lt;br&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;刷题&lt;br&gt;categories:&lt;/li&gt;
&lt;li&gt;剑指offer&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;11-
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>topic-07-08</title>
    <link href="http://yoursite.com/2020/02/17/topic-07-08/"/>
    <id>http://yoursite.com/2020/02/17/topic-07-08/</id>
    <published>2020-02-17T09:56:11.000Z</published>
    <updated>2020-02-18T12:17:03.774Z</updated>
    
    <content type="html"><![CDATA[<h2 id="07-菲波那切数列"><a href="#07-菲波那切数列" class="headerlink" title="07-菲波那切数列"></a>07-菲波那切数列</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。n&lt;=39</p></blockquote><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>利用传统的递归方法会有重复计算，时间复杂度也会超过限制，在这里利用三个变量进行简单的循环即可<br><strong>时间复杂度：O(n),空间复杂度：O(1)</strong></p><blockquote><p>代码如下： </p></blockquote><pre><code class="lang-c++">class Solution {public:    int Fibonacci(int n) {        int res=0;        if(n==0||n==1){            return n;        }        int one=0,two=1,three=0;        for(int i=2;i&lt;=n;i++){            three=one+two;            one=two;            two=three;        }        return three;    }};</code></pre><h2 id="08-跳台阶"><a href="#08-跳台阶" class="headerlink" title="08-跳台阶"></a>08-跳台阶</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。  </p></blockquote><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>思想同上一题：菲波那切数列<br><strong>时间复杂度：O(n),空间复杂度：O(1)</strong></p><blockquote><p>代码如下： </p></blockquote><pre><code class="lang-c++">class Solution {public:    int jumpFloor(int number) {        if(number&lt;=0){            return 0;        }        else if(number &lt;3){            return number;        }        int one=1,two=2,three=0;        for(int i=3;i&lt;=number;i++){            three=one + two;            one=two;            two=three;        }        return three;    }};</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;07-菲波那切数列&quot;&gt;&lt;a href=&quot;#07-菲波那切数列&quot; class=&quot;headerlink&quot; title=&quot;07-菲波那切数列&quot;&gt;&lt;/a&gt;07-菲波那切数列&lt;/h2&gt;&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="刷题" scheme="http://yoursite.com/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>05-09</title>
    <link href="http://yoursite.com/2020/02/16/05-09/"/>
    <id>http://yoursite.com/2020/02/16/05-09/</id>
    <published>2020-02-16T02:01:05.000Z</published>
    <updated>2020-02-16T02:15:15.618Z</updated>
    
    <content type="html"><![CDATA[<h2 id="05-替换空格"><a href="#05-替换空格" class="headerlink" title="05-替换空格"></a>05-替换空格</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。  </p></blockquote><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>先找到空格数目，然后从后往前依次遍历原字符串，判断是否为空格，若为空格将空格替换为’%20’</p><blockquote><p>代码如下：  </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replaceSpace</span><span class="params">(<span class="keyword">char</span> *str,<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> numSpace=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(str[i]!=<span class="string">'\0'</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i]==<span class="string">' '</span>)&#123;</span><br><span class="line">                numSpace++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> newLen=i+<span class="number">2</span>*numSpace;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;=<span class="number">0</span>,newLen&gt;=<span class="number">0</span>;)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[j]==<span class="string">' '</span>)&#123;</span><br><span class="line">                str[newLen--]=<span class="string">'0'</span>;</span><br><span class="line">                str[newLen--]=<span class="string">'2'</span>;</span><br><span class="line">                str[newLen--]=<span class="string">'%'</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                str[newLen--]=str[j];</span><br><span class="line">            &#125;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p></blockquote><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><blockquote><p>利用栈的先进后出的特点，在实现队列的弹出的方法时，现将stack1的数值弹出到stack2中，然后弹出stack2的第一个元素即可</p></blockquote><h3 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack1.push(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack2.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(stack1.size()&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> data=stack1.top();</span><br><span class="line">                stack1.pop();</span><br><span class="line">                stack2.push(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> popItem=stack2.top();</span><br><span class="line">        stack2.pop();</span><br><span class="line">        <span class="keyword">return</span> popItem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack1;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;05-替换空格&quot;&gt;&lt;a href=&quot;#05-替换空格&quot; class=&quot;headerlink&quot; title=&quot;05-替换空格&quot;&gt;&lt;/a&gt;05-替换空格&lt;/h2&gt;&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="刷题" scheme="http://yoursite.com/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>topic06-07</title>
    <link href="http://yoursite.com/2020/02/15/topic06/"/>
    <id>http://yoursite.com/2020/02/15/topic06/</id>
    <published>2020-02-15T03:36:14.000Z</published>
    <updated>2020-02-15T03:52:39.120Z</updated>
    
    <content type="html"><![CDATA[<h2 id="06-从尾到头打印链表"><a href="#06-从尾到头打印链表" class="headerlink" title="06-从尾到头打印链表"></a>06-从尾到头打印链表</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p></blockquote><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><p>用一个栈从头到尾遍历链表，依次压入栈中，然后利用栈的先进后出的特点，依次弹出放入res数组中<br><strong>时间复杂度：O(n),空间复杂度：O(n)</strong></p><blockquote><p>代码  </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; reversePrint(ListNode* head) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; nodes;</span><br><span class="line">        ListNode* node=head;</span><br><span class="line">        <span class="keyword">while</span>(node!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">            nodes.push(node-&gt;val);</span><br><span class="line">            node=node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty())&#123;</span><br><span class="line">            res.push_back(nodes.top());</span><br><span class="line">            nodes.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="07-重建二叉树"><a href="#07-重建二叉树" class="headerlink" title="07-重建二叉树"></a>07-重建二叉树</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p></blockquote><p>例如，给出</p><pre><code>前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]</code></pre><h3 id="解法-1"><a href="#解法-1" class="headerlink" title="解法"></a>解法</h3><p>利用前序遍历，中序遍历的特点，分别建立preLeft,preRight,inLeft,inRight四个数组，分别保存前序数组除去根节点的左子树节点，前序数组的右子树节点，中序数组的左子树节点，中序数组的右子树节点，然后以前序数组第一个数字为根节点的val，递归生成根节点的左子树，右子树  </p><blockquote><p>代码  </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preLeft,preRight,inLeft,inRight;</span><br><span class="line">        TreeNode* head=<span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> root=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inorder.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inorder[i]==preorder[<span class="number">0</span>])&#123;</span><br><span class="line">                root=i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;root;i++)&#123;</span><br><span class="line">            inLeft.push_back(inorder[i]);</span><br><span class="line">            preLeft.push_back(preorder[i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=root+<span class="number">1</span>;i&lt;preorder.size();i++)&#123;</span><br><span class="line">            inRight.push_back(inorder[i]);</span><br><span class="line">            preRight.push_back(preorder[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;left=buildTree(preLeft,inLeft);</span><br><span class="line">        head-&gt;right=buildTree(preRight,inRight);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;06-从尾到头打印链表&quot;&gt;&lt;a href=&quot;#06-从尾到头打印链表&quot; class=&quot;headerlink&quot; title=&quot;06-从尾到头打印链表&quot;&gt;&lt;/a&gt;06-从尾到头打印链表&lt;/h2&gt;&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="刷题" scheme="http://yoursite.com/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020/02/14/%E5%89%91%E6%8C%87offer-02-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2020/02/14/%E5%89%91%E6%8C%87offer-02-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/</id>
    <published>2020-02-14T10:55:05.681Z</published>
    <updated>2020-02-14T10:55:05.682Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: 剑指offer-02<br>date: 2020-02-14 17:33:47<br>tags:</p><ul><li>刷题<br>categories:</li><li>剑指offer</li></ul><hr><h2 id="二维数组的查找"><a href="#二维数组的查找" class="headerlink" title="二维数组的查找"></a>二维数组的查找</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p></blockquote><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>先判断数组是否为空，然后定义row,col,从第一行最后一个数字开始与target比较，如果比target大，则col减一，若比target小，则row+1，否则相等，返回true   </p><blockquote><p>代码  </p></blockquote><pre><code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty()|| matrix[<span class="number">0</span>].size()==<span class="number">0</span>||matrix.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> col=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> row=matrix.size();</span><br><span class="line">        <span class="keyword">int</span> i=col<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&lt;row)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(target&gt;matrix[j][i])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&lt;matrix[j][i])&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: 剑指offer-02&lt;br&gt;date: 2020-02-14 17:33:47&lt;br&gt;tags:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;刷题&lt;br&gt;categories:&lt;/li&gt;
&lt;li&gt;剑指offer&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;二维数组
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>02-二维数组的查找</title>
    <link href="http://yoursite.com/2020/02/14/test/"/>
    <id>http://yoursite.com/2020/02/14/test/</id>
    <published>2020-02-14T09:56:24.000Z</published>
    <updated>2020-02-14T10:30:28.738Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二维数组的查找"><a href="#二维数组的查找" class="headerlink" title="二维数组的查找"></a>二维数组的查找</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p></blockquote><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>先判断数组是否为空，然后定义row,col,从第一行最后一个数字开始与target比较，如果比target大，则col减一，若比target小，则row+1，否则相等，返回true   </p><blockquote><p>代码  </p></blockquote><pre><code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.empty()|| matrix[<span class="number">0</span>].size()==<span class="number">0</span>||matrix.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> col=matrix[<span class="number">0</span>].size();</span><br><span class="line">        <span class="keyword">int</span> row=matrix.size();</span><br><span class="line">        <span class="keyword">int</span> i=col<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>&amp;&amp;j&lt;row)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(target&gt;matrix[j][i])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target&lt;matrix[j][i])&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二维数组的查找&quot;&gt;&lt;a href=&quot;#二维数组的查找&quot; class=&quot;headerlink&quot; title=&quot;二维数组的查找&quot;&gt;&lt;/a&gt;二维数组的查找&lt;/h2&gt;&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="刷题" scheme="http://yoursite.com/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-03.数组中重复的数字</title>
    <link href="http://yoursite.com/2020/02/14/%E5%89%91%E6%8C%87offer-03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/02/14/%E5%89%91%E6%8C%87offer-03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</id>
    <published>2020-02-14T02:05:08.000Z</published>
    <updated>2020-02-14T02:55:45.579Z</updated>
    
    <content type="html"><![CDATA[<h2 id="找出数组中重复的数字"><a href="#找出数组中重复的数字" class="headerlink" title="找出数组中重复的数字"></a>找出数组中重复的数字</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p></blockquote><h3 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h3><p>首先判断数组长度是否为0或1，若是，则返回-1，然后将数组排序，然后比较数组中前一个数字是否和后一个数字相等，如果相等，则返回该数字<br><strong>时间复杂度 O(nlog(n)),空间复杂度: O(1)</strong></p><blockquote><p>代码  </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">int</span> flag=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==flag)&#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            flag=nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h3><p>因为题目的数组的特殊性，所以可以假设该数组的位置i上的数字为i，即索引与该索引位置上的值相等<br>遍历该数组，如果位置i上的数字为i，则指针后移，如果不等，判断nums[i]是否等于nums[nums[i]]，如果相等，则找到第一个重复的数字，如果不等，将两个数字交换位置，这样，nums[i]位置上的值就等于nums[i],然后继续判断比较，知道位置i上的数字为i，然后往后顺移，直到遍历结束或者找到重复的数字<br><strong>时间复杂度：O(n),空间复杂度: O(1)</strong> </p><blockquote><p>代码如下： </p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size()&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(nums[i]!=i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]==nums[nums[i]])&#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                swap(nums[i],nums[nums[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;找出数组中重复的数字&quot;&gt;&lt;a href=&quot;#找出数组中重复的数字&quot; class=&quot;headerlink&quot; title=&quot;找出数组中重复的数字&quot;&gt;&lt;/a&gt;找出数组中重复的数字&lt;/h2&gt;&lt;h3 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="剑指offer" scheme="http://yoursite.com/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="刷题" scheme="http://yoursite.com/tags/%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>某R(配搭黑科技号服务的使用说明)</title>
    <link href="http://yoursite.com/2020/02/12/ShadowSocksR-%E9%85%8D%E6%90%AD%E9%BB%91%E7%A7%91%E6%8A%80%E5%8F%B7%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>http://yoursite.com/2020/02/12/ShadowSocksR-%E9%85%8D%E6%90%AD%E9%BB%91%E7%A7%91%E6%8A%80%E5%8F%B7%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</id>
    <published>2020-02-12T08:41:12.000Z</published>
    <updated>2020-02-12T09:10:40.146Z</updated>
    
    <content type="html"><![CDATA[<h2 id="某R-配搭黑科技号服务的使用说明"><a href="#某R-配搭黑科技号服务的使用说明" class="headerlink" title="某R(配搭黑科技号服务的使用说明)"></a>某R(配搭黑科技号服务的使用说明)</h2><blockquote><p><a href="https://blog.kingsbestone.com/?p=269" target="_blank" rel="noopener">参考链接:</a><br>由于安全原因，暂不在此详细说明，详情请参考参考链接，尊重博主劳动成果!</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;某R-配搭黑科技号服务的使用说明&quot;&gt;&lt;a href=&quot;#某R-配搭黑科技号服务的使用说明&quot; class=&quot;headerlink&quot; title=&quot;某R(配搭黑科技号服务的使用说明)&quot;&gt;&lt;/a&gt;某R(配搭黑科技号服务的使用说明)&lt;/h2&gt;&lt;blockquote&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="教程" scheme="http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="使用说明" scheme="http://yoursite.com/tags/%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    
  </entry>
  
  <entry>
    <title>git在项目中的操作记录</title>
    <link href="http://yoursite.com/2020/02/10/git%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/02/10/git%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E6%93%8D%E4%BD%9C%E8%AE%B0%E5%BD%95/</id>
    <published>2020-02-10T13:30:37.000Z</published>
    <updated>2020-02-17T02:21:30.542Z</updated>
    
    <content type="html"><![CDATA[<h2 id="git在项目中的操作记录"><a href="#git在项目中的操作记录" class="headerlink" title="git在项目中的操作记录"></a>git在项目中的操作记录</h2><h3 id="将本地代码上传到远程仓库"><a href="#将本地代码上传到远程仓库" class="headerlink" title="将本地代码上传到远程仓库"></a>将本地代码上传到远程仓库</h3><blockquote><p>首先进入要上传代码的目录,例如,我要将test文件夹下的代码上传到rep,使用命令,</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd test</span><br></pre></td></tr></table></figure><p>通常需要创建README.md文件,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;# test&quot; &gt;&gt; README.md</span><br></pre></td></tr></table></figure><p>执行git命令，此命令会在当前目录下创建一个.git文件夹,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>将项目的所有文件添加到仓库中,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br></pre></td></tr></table></figure><p>这个命令会把当前路径下的所有文件，添加到待上传的文件列表中。如果想添加某个特定的文件，只需把.换成特定的文件名即可.</p><p>将add的文件commit到仓库,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;注释语句&quot;</span><br></pre></td></tr></table></figure><p>也可以直接在idea上 选择 ： VCS  -&gt; import into version controle -&gt; create git Repositiry创建本地仓库</p><p>之后,去github上创建自己的Repository，点击NewRepository,</p><p>将本地的仓库关联到github上,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/****/test.git</span><br></pre></td></tr></table></figure><p>上传代码到github远程仓库,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>输入Username和Password，即输入github的账号和密码就行了.如果没有异常，等待执行完就上传成功了</p><p>若要取消本地目录下关联的远程库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote remove origin</span><br></pre></td></tr></table></figure><p>如果远程仓库已有文件，要替换掉远程文件，否则直接push会出错，两种解决办法：</p><ul><li>1、强推，即利用强覆盖方式用你本地的代码替代git仓库内的内容，如果远程仓库是刚建的，没有代码，可以这样操作，尽量避免这种操作方法。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -f</span><br></pre></td></tr></table></figure><ul><li>2、先把git的东西fetch到你本地然后merge后再push</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git fetch</span><br><span class="line">$ git merge</span><br></pre></td></tr></table></figure><ul><li>3、在使用的时候，git merge，又出现了以下的问题</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: refusing to merge unrelated histories</span><br></pre></td></tr></table></figure><p>对于这个问题。使用<code>git pull origin master --allow-unrelated-histories</code><br>来处理一下。</p><ul><li>4、然后继续git merge,依然有问题</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fatal: You have not concluded your merge (MERGE_HEAD exists).</span><br><span class="line">Please, commit your changes before you merge.</span><br></pre></td></tr></table></figure><p>这个就好处理了，是我们没有提交当前的变化， <code>git add .,git commit -am &quot;提交信息&quot;</code></p><p>然后再来一次<code>git merge</code>,然后ok.</p><ul><li>5、然后输入<code>git pull</code>,显示如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Already up-to-date.</span><br></pre></td></tr></table></figure><h3 id="master合并其他分支-例如：index分支"><a href="#master合并其他分支-例如：index分支" class="headerlink" title="master合并其他分支(例如：index分支)"></a>master合并其他分支(例如：index分支)</h3><blockquote><p>在index分支上push之后，执行语句：  </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">```  </span><br><span class="line">&gt;切换到master分支，然后执行语句：</span><br></pre></td></tr></table></figure><p>git merge origin/index<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;在本地上与index分支合并，然后执行语句</span><br></pre></td></tr></table></figure></p><p>git push<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;将master分支push到远程master分支</span><br><span class="line"></span><br><span class="line">### 标签管理  </span><br><span class="line"></span><br><span class="line">#### 创建标签  </span><br><span class="line">&gt;切换到需要打标签的版本，然后输入 git tag &lt;name&gt; 就可以打上一个标签。另外，可以用 `git tag` 查看所有标签：</span><br><span class="line"></span><br><span class="line">```git</span><br><span class="line">git checkout master</span><br><span class="line">git tag v1.0.0</span><br></pre></td></tr></table></figure></p><blockquote><p>利用<code>git tag</code> 查看标签<br>默认标签是打在最新提交的commit上的。但是，如果需要对过去的提交的版本打上标签，怎么操作？</p></blockquote><p>方法是找到历史提交的commit id（命令：<code>git log --pretty=oneline --abbrev-commit）</code>，然后打上就可以了：</p><p>例如： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag v1.0.1 6a691d8</span><br></pre></td></tr></table></figure><blockquote><p>还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字：  </p></blockquote><h4 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h4><blockquote><p>如果标签打错了，也可以删除，使用命令 <code>git tag -d &lt;tagname&gt;</code> </p></blockquote><p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。  </p><h4 id="推送标签至远程"><a href="#推送标签至远程" class="headerlink" title="推送标签至远程"></a>推送标签至远程</h4><p>如果要推送某个标签到远程，使用命令 <code>git push origin &lt;tagname&gt;</code><br>或者，一次性推送全部尚未推送到远程的本地标签（命令：<code>git push origin --tags</code> ） </p><h4 id="删除远程标签"><a href="#删除远程标签" class="headerlink" title="删除远程标签"></a>删除远程标签</h4><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除（命令：<code>git tag -d v1.0.0</code> ），然后再从远程删除（命令：<code>git push origin :refs/tags/&lt;tagname&gt;</code> ）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;git在项目中的操作记录&quot;&gt;&lt;a href=&quot;#git在项目中的操作记录&quot; class=&quot;headerlink&quot; title=&quot;git在项目中的操作记录&quot;&gt;&lt;/a&gt;git在项目中的操作记录&lt;/h2&gt;&lt;h3 id=&quot;将本地代码上传到远程仓库&quot;&gt;&lt;a href=&quot;#将
      
    
    </summary>
    
    
      <category term="项目笔记" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="git操作" scheme="http://yoursite.com/tags/git%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>搭建个人博客教程</title>
    <link href="http://yoursite.com/2020/02/09/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/02/09/%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/</id>
    <published>2020-02-09T02:44:31.000Z</published>
    <updated>2020-02-10T13:36:07.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="搭建个人博客"><a href="#搭建个人博客" class="headerlink" title="搭建个人博客"></a>搭建个人博客</h2><blockquote><p>本文是参考大才哥的搭建博客文章所写的供个人备忘的教程  </p></blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzIzNzA4NDk3Nw==&amp;mid=2457738181&amp;idx=1&amp;sn=0a204aa85ef7db1df0ff93c178121315&amp;chksm=ff44b39bc8333a8d14adcec4df4c2bd305d67e0711526ade76f54d37a573e8d37efc0c4b64f6&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1569519232027&amp;sharer_shareid=6ff842664bb7466b1c815a9bbf97c1f8#rd" target="_blank" rel="noopener">参考链接</a></p><h3 id="准备条件"><a href="#准备条件" class="headerlink" title="准备条件"></a>准备条件</h3><p>首先在 GitHub 新建一个仓库（Repository），名称为   {username}.github.io，注意这个名比较特殊，必须要是 github.io   为后缀结尾的。比如 Alexxigang 的 GitHub 用户名就叫 Alexxigang，  那我就新建一个 Alexxigang.github.io，新建完成之后就可以进行后续  操作了。</p><p>另外如果 GitHub 没有配置 SSH 连接的建议配置一下，这样后面在部署博   客的时候会更方便。  </p><h3 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h3><blockquote><p>安装 Node.js  </p></blockquote><p>首先在自己的电脑上安装 Node.js，下载地址：<a href="https://nodejs.org/zh-cn/download/，可以安装" target="_blank" rel="noopener">https://nodejs.org/zh-cn/download/，可以安装</a> Stable 版本。  </p><p>安装完毕之后，确保环境变量配置好，能正常使用 npm 命令。  </p><blockquote><p>安装 Hexo  </p></blockquote><p>接下来就需要安装 Hexo 了，这是一个博客框架，Hexo 官方还提供了一个命令行工具，用于快速创建项目、页面、编译、部署 Hexo 博客，所以在这之前我们需要先安装 Hexo 的命令行工具。</p><p>命令如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装完毕之后，确保环境变量配置好，能正常使用 hexo 命令。</p><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p>接下来我们使用 Hexo 的命令行创建一个项目，并将其在本地跑起来，整体跑通看看。</p><p>首先使用如下命令创建项目：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init &#123;name&#125;</span><br></pre></td></tr></table></figure><p>这里的 name 就是项目名，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init alexxigang</span><br></pre></td></tr></table></figure><p>这样 alexxigang 文件夹下就会出现 Hexo 的初始化文件，包括 themes、scaffolds、source 等文件夹，这些内容暂且先不用管是做什么的，我们先知道有什么，然后一步步走下去看看都发生了什么变化。</p><p>接下来我们首先进入新生成的文件夹里面，然后调用 Hexo 的 generate 命令，将 Hexo 编译生成 HTML 代码，命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure></p><p>可以看到输出结果里面包含了 js、css、font 等内容，并发现他们都处在了项目根目录下的 public 文件夹下面了。</p><p>然后我们利用 Hexo 提供的 serve 命令把博客在本地运行起来，命令如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo serve</span><br><span class="line">```  </span><br><span class="line">运行之后命令行输出如下：</span><br></pre></td></tr></table></figure><p>INFO  Start processing<br>INFO  Hexo is running at <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> . Press Ctrl+C to stop.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">它告诉我们在本地 4000 端口上就可以查看博客站点了，如图所示：  </span><br><span class="line">![图片](https://mmbiz.qpic.cn/mmbiz_png/a0YItejHaTA1bncwcib5h56zF17LTYkiaMxKicia83rNGIraZdjS8jF7KaxHFpF0G01ia2xNdR2CjiccCHnuDkuCQMhg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1)  </span><br><span class="line"></span><br><span class="line">### 部署  </span><br><span class="line"></span><br><span class="line">接下来我们来将这个初始化的博客进行一下部署，放到 GitHub Pages 上面验证一下其可用性。成功之后我们可以再进行后续的修改，比如修改主题、修改页面配置等等。</span><br><span class="line"></span><br><span class="line">那么怎么把这个页面部署到 GitHub Pages 上面呢，其实 Hexo 已经给我们提供一个命令，利用它我们可以直接将博客一键部署，不需要手动去配置服务器或进行其他的各项配置。</span><br><span class="line"></span><br><span class="line">部署命令如下：</span><br></pre></td></tr></table></figure></p><p>hexo deploy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在部署之前，我们需要先知道博客的部署地址，它需要对应 GitHub 的一个 Repository 的地址，这个信息需要我们来配置一下。</span><br><span class="line"></span><br><span class="line">打开根目录下的 _config.yml 文件，找到 Deployment 这个地方，把刚才新建的 Repository 的地址贴过来，然后指定分支为 master 分支，最终修改为如下内容：</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &#123;git repo ssh address&#125;</span><br><span class="line">  branch: master</span><br><span class="line"></span><br><span class="line">我的就修改为如下内容：  </span><br><span class="line"></span><br><span class="line"># Deployment</span><br><span class="line">## Docs: https://hexo.io/docs/deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:Alexxigang/alexxigang.github.io.git</span><br><span class="line">  branch: master  </span><br><span class="line"></span><br><span class="line">另外我们还需要额外安装一个支持 Git 的部署插件，名字叫做 hexo-deployer-git，有了它我们才可以顺利将其部署到 GitHub 上面，如果不安装的话，在执行部署命令时会报如下错误：  </span><br><span class="line"></span><br><span class="line">```Deployer not found: git</span><br></pre></td></tr></table></figure></p><p>好，那就让我们安装下这个插件，在项目目录下执行安装命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p>安装成功之后，执行部署命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></p><p>运行结果类似如下： </p><pre><code>INFO  Deploying: gitINFO  Clearing .deploy_git folder...INFO  Copying files from public folder...INFO  Copying files from extend dirs...On branch masternothing to commit, working directory cleanCounting objects: 46, done.Delta compression using up to 8 threads.Compressing objects: 100% (36/36), done.Writing objects: 100% (46/46), 507.66 KiB | 0 bytes/s, done.Total 46 (delta 3), reused 0 (delta 0)remote: Resolving deltas: 100% (3/3), done.To git@github.com:NightTeam/nightteam.github.io.git * [new branch]      HEAD -&gt; masterBranch master set up to track remote branch master from git@github.com:Alexxigang/alexxigang.github.io.git.INFO  Deploy done: git  </code></pre><p>如果出现类似上面的内容，就证明我们的博客已经成功部署到 GitHub Pages 上面了，这时候我们访问一下 GitHub Repository 同名的链接，比如我的 Alexxigang 博客的 Repository 名称取的是 alexxigang.github.io，那我就访问 <a href="http://alexxigang.github.io，这时候我们就可以看到跟本地一模一样的博客内容了。" target="_blank" rel="noopener">http://alexxigang.github.io，这时候我们就可以看到跟本地一模一样的博客内容了。</a>  </p><p>这时候我们去 GitHub 上面看看 Hexo 上传了什么内容，打开之后可以看到 master 分支有了这样的内容：<br><img src="https://mmbiz.qpic.cn/mmbiz_png/a0YItejHaTA1bncwcib5h56zF17LTYkiaMuibX5a56AT9B1Q10ibTL4WTrhuX10AXdAxDyALBJqB2Sn3geB8rSvn9A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt>  </p><p>仔细看看，这实际上是博客文件夹下面的 public 文件夹下的所有内容，Hexo 把编译之后的静态页面内容上传到 GitHub 的 master 分支上面去了。</p><p>这时候可能就有人有疑问了，那我博客的源码也想放到 GitHub 上面怎么办呢？其实很简单，新建一个其他的分支就好了，比如我这边就新建了一个 source 分支，代表博客源码的意思。</p><p>具体的添加过程就很简单了，参加如下命令：  </p><pre><code>git initgit checkout -b sourcegit add -Agit commit -m &quot;init blog&quot;git remote add origin git@github.com:{username}/{username}.github.io.gitgit push origin source   </code></pre><p>成功之后，可以到 GitHub 上再切换下默认分支，比如我就把默认的分支设置为了 source，当然不换也可以。  </p><h3 id="配置站点信息"><a href="#配置站点信息" class="headerlink" title="配置站点信息"></a>配置站点信息</h3><p>修改根目录下的 _config.yml 文件，找到 Site 区域，这里面可以配置站点标题 title、副标题 subtitle 等内容、关键字 keywords 等内容，比如我的就修改为如下内容：  </p><pre><code>title: Alexxigangsubtitle: 专注技术description: 主要分享个人学习笔记，个人总结等文章keywords: &quot;java ,c++, linux, python ,深度学习，等等&quot;author: Alexlanguage: zh-CNtimezone:  </code></pre><h3 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h3><p>目前来看，整个页面的样式个人感觉并不是那么好看，想换一个风格，这就涉及到主题的配置了。目前 Hexo 里面应用最多的主题基本就是 Next 主题了，个人感觉这个主题还是挺好看的，另外它支持的插件和功能也极为丰富，配置了这个主题，我们的博客可以支持更多的扩展功能，比如阅览进度条、中英文空格排版、图片懒加载等等。</p><p>那么首先就让我们来安装下 Next 这个主题吧，目前 Next 主题已经更新到 7.x 版本了，我们可以直接到 Next 主题的 GitHub Repository 上把这个主题下载下来。</p><p>主题的 GitHub 地址是：<a href="https://github.com/theme-next/hexo-theme-next，我们可以直接把" target="_blank" rel="noopener">https://github.com/theme-next/hexo-theme-next，我们可以直接把</a> master 分支 Clone 下来。</p><p>首先命令行进入到项目的根目录，执行如下命令即可：<br><figure class="highlight plain"><figcaption><span>clone</span><a href="https://github.com/theme-next/hexo-theme-next" target="_blank" rel="noopener">themes/next</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```  </span><br><span class="line">执行完毕之后 Next 主题的源码就会出现在项目的 themes/next 文件夹下。</span><br><span class="line"></span><br><span class="line">然后我们需要修改下博客所用的主题名称，修改项目根目录下的 _config.yml 文件，找到 theme 字段，修改为 next 即可，修改如下：  </span><br><span class="line">```theme: next</span><br></pre></td></tr></table></figure></p><p>然后本地重新开启服务，访问刷新下页面，就可以看到 next 主题就切换成功了  </p><h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><p>现在我们已经成功切换到 next 主题上面了，接下来我们就对主题进行进一步地详细配置吧，比如修改样式、增加其他各项功能的支持，下面逐项道来。</p><p>Next 主题内部也提供了一个配置文件，名字同样叫做 _config.yml，只不过位置不一样，它在 themes/next 文件夹下，Next 主题里面所有的功能都可以通过这个配置文件来控制，下文所述的内容都是修改的 themes/next/_config.yml 文件。 </p><h4 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h4><p>Next 主题还提供了多种样式，风格都是类似黑白的搭配，但整个布局位置不太一样，通过修改配置文件的 scheme 字段即可，我选了 Pisces 样式，修改 _config.yml （注意是 themes/next/_config.yml 文件）如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme: Pisces</span><br></pre></td></tr></table></figure><p>另外还有几个可选项，比如： </p><pre><code># scheme: Muse#scheme: Mistscheme: Pisces#scheme: Gemini  </code></pre><h4 id="favicon"><a href="#favicon" class="headerlink" title="favicon"></a>favicon</h4><blockquote><p>favicon 就是站点标签栏的小图标，默认是用的 Hexo 的小图标，如果我们有站点 Logo 的图片的话，我们可以自己定制小图标。  </p></blockquote><p>但这并不意味着我们需要自己用 PS 自己来设计，已经有一个网站可以直接将图片转化为站点小图标，站点链接为：<a href="https://realfavicongenerator.net[1]，到这里上传一张图，便可以直接打包下载各种尺寸和适配不同设备的小图标。" target="_blank" rel="noopener">https://realfavicongenerator.net[1]，到这里上传一张图，便可以直接打包下载各种尺寸和适配不同设备的小图标。</a></p><p>图标下载下来之后把它放在 themes/next/source/images 目录下面。</p><p>然后在配置文件里面找到 favicon 配置项，把一些相关路径配置进去即可，示例如下：  </p><pre><code>favicon:  small: /images/favicon-16x16.png  medium: /images/favicon-32x32.png  apple_touch_icon: /images/apple-touch-icon.png  safari_pinned_tab: /images/safari-pinned-tab.svg  </code></pre><h4 id="rss"><a href="#rss" class="headerlink" title="rss"></a>rss</h4><p>博客一般是需要 RSS 订阅的，如果要开启 RSS 订阅，这里需要安装一个插件，叫做 hexo-generator-feed，安装完成之后，站点会自动生成 RSS Feed 文件，安装命令如下：  </p><figure class="highlight plain"><figcaption><span>install hexo-generator-feed --save</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">在项目根目录下运行这个命令，安装完成之后不需要其他的配置，以后每次编译生成站点的时候就会自动生成 RSS Feed 文件了。  </span><br><span class="line"></span><br><span class="line">#### code  </span><br><span class="line"></span><br><span class="line">作为程序猿，代码块的显示还是需要很讲究的，默认的代码块我个人不是特别喜欢，因此我把代码的颜色修改为黑色，并把复制按钮的样式修改为类似 Mac 的样式，修改 _config.yml 文件（注意是 themes/next/_config.yml 文件）的 codeblock 区块如下：  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">codeblock:</span><br><span class="line">  # Code Highlight theme</span><br><span class="line">  # Available values: normal | night | night eighties | night blue | night bright</span><br><span class="line">  # See: https://github.com/chriskempson/tomorrow-theme</span><br><span class="line">  highlight_theme: night bright</span><br><span class="line">  # Add copy button on codeblock</span><br><span class="line">  copy_button:</span><br><span class="line">    enable: true</span><br><span class="line">    # Show text copy result.</span><br><span class="line">    show_result: true</span><br><span class="line">    # Available values: default | flat | mac</span><br><span class="line">    style: mac  </span><br><span class="line"></span><br><span class="line">#### top  </span><br><span class="line"></span><br><span class="line">我们在浏览网页的时候，如果已经看完了想快速返回到网站的上端，一般都是有一个按钮来辅助的，这里也支持它的配置，修改 _config.yml 的 back2top 字段即可，我的设置如下：  </span><br><span class="line"></span><br><span class="line">back2top:</span><br><span class="line">  enable: true</span><br><span class="line">  # Back to top in sidebar.</span><br><span class="line">  sidebar: false</span><br><span class="line">  # Scroll percent label in b2t button.</span><br><span class="line">  scrollpercent: true  </span><br><span class="line"></span><br><span class="line">enable 默认为 true，即默认显示。sidebar 如果设置为 true，按钮会出现在侧栏下方，个人觉得并不是很好看，就取消了，scrollpercent 就是显示阅读百分比，个人觉得还不错，就将其设置为 true。</span><br><span class="line"></span><br><span class="line">具体的效果大家可以设置后根据喜好选择。  </span><br><span class="line"></span><br><span class="line">#### reading_process   </span><br><span class="line">reading_process，阅读进度。大家可能注意到有些站点的最上侧会出现一个细细的进度条，代表页面加载进度和阅读进度，如果大家想设置的话也可以试试，我将其打开了，修改 _config.yml（注意是 themes/next/_config.yml 文件） 如下：  </span><br><span class="line"></span><br><span class="line">reading_progress:</span><br><span class="line">  enable: true</span><br><span class="line">  # Available values: top | bottom</span><br><span class="line">  position: top</span><br><span class="line">  color: &quot;#222&quot;</span><br><span class="line">  height: 2px  </span><br><span class="line">#### bookmark  </span><br><span class="line"></span><br><span class="line">书签，可以根据阅读历史记录，在下次打开页面的时候快速帮助我们定位到上次的位置，大家可以根据喜好开启和关闭，我的配置如下：  </span><br><span class="line"></span><br><span class="line">bookmark:</span><br><span class="line">  enable: false</span><br><span class="line">  # Customize the color of the bookmark.</span><br><span class="line">  color: &quot;#222&quot;</span><br><span class="line">  # If auto, save the reading progress when closing the page or clicking the bookmark-icon.</span><br><span class="line">  # If manual, only save it by clicking the bookmark-icon.</span><br><span class="line">  save: auto   </span><br><span class="line"></span><br><span class="line">#### github_banner </span><br><span class="line">在一些技术博客上，大家可能注意到在页面的右上角有个 GitHub 图标，点击之后可以跳转到其源码页面，可以为 GitHub Repository 引流，大家如果想显示的话可以自行选择打开，我的配置如下：  </span><br><span class="line"></span><br><span class="line"># `Follow me on GitHub` banner in the top-right corner.</span><br><span class="line">github_banner:</span><br><span class="line">  enable: true</span><br><span class="line">  permalink: https://github.com/Alexxigang/alexxigang.github.io</span><br><span class="line">  title: alex  </span><br><span class="line"></span><br><span class="line">记得修改下链接 permalink 和标题 title  </span><br><span class="line"></span><br><span class="line">可以看到在页面右上角显示了 GitHub 的图标，点击可以进去到 Repository 页面。  </span><br><span class="line"></span><br><span class="line">#### gitalk  </span><br><span class="line"></span><br><span class="line">由于 Hexo 的博客是静态博客，而且也没有连接数据库的功能，所以它的评论功能是不能自行集成的，但可以集成第三方的服务。</span><br><span class="line"></span><br><span class="line">Next 主题里面提供了多种评论插件的集成，有 changyan | disqus | disqusjs | facebook_comments_plugin | gitalk | livere | valine | vkontakte 这些。</span><br><span class="line"></span><br><span class="line">作为一名程序员，我个人比较喜欢 gitalk，它是利用 GitHub 的 Issue 来当评论，样式也比较不错。</span><br><span class="line"></span><br><span class="line">首先需要在 GitHub 上面注册一个 OAuth Application，链接为：https://github.com/settings/applications/new，注册完毕之后拿到 Client ID、Client Secret 就可以了。</span><br><span class="line"></span><br><span class="line">首先需要在 _config.yml 文件（注意是 themes/next/_config.yml 文件）的 comments 区域配置使用 gitalk：  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Multiple Comment System Support</span><br><span class="line">comments:</span><br><span class="line">  # Available values: tabs | buttons</span><br><span class="line">  style: tabs</span><br><span class="line">  # Choose a comment system to be displayed by default.</span><br><span class="line">  # Available values: changyan | disqus | disqusjs | facebook_comments_plugin | gitalk | livere | valine | vkontakte </span><br><span class="line">  active: gitalk  </span><br><span class="line"></span><br><span class="line">主要是 comments.active 字段选择对应的名称即可。</span><br><span class="line"></span><br><span class="line">然后找打 gitalk 配置，添加它的各项配置：</span><br><span class="line"></span><br><span class="line"># Gitalk</span><br><span class="line"># Demo: https://gitalk.github.io</span><br><span class="line"># For more information: https://github.com/gitalk/gitalk</span><br><span class="line">gitalk:</span><br><span class="line">  enable: true</span><br><span class="line">  github_id: NightTeam</span><br><span class="line">  repo: nightteam.github.io # Repository name to store issues</span><br><span class="line">  client_id: &#123;your client id&#125; # GitHub Application Client ID</span><br><span class="line">  client_secret: &#123;your client secret&#125; # GitHub Application Client Secret</span><br><span class="line">  admin_user: germey # GitHub repo owner and collaborators, only these guys can initialize gitHub issues</span><br><span class="line">  distraction_free_mode: true # Facebook-like distraction free mode</span><br><span class="line">  # Gitalk&apos;s display language depends on user&apos;s browser or system environment</span><br><span class="line">  # If you want everyone visiting your site to see a uniform language, you can set a force language value</span><br><span class="line">  # Available values: en | es-ES | fr | ru | zh-CN | zh-TW</span><br><span class="line">  language: zh-CN  </span><br><span class="line"></span><br><span class="line">配置完成之后 gitalk 就可以使用了，点击进入文章页面，就会出现如下页面：  </span><br><span class="line">![](https://mmbiz.qpic.cn/mmbiz_png/a0YItejHaTA1bncwcib5h56zF17LTYkiaMicLD2PyQSYWKqb7o41zibEIj8BVjiac7KpllTy5Co4b5h83yB0jOQfH3Q/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1)  </span><br><span class="line"></span><br><span class="line">GitHub 授权登录之后就可以使用了，评论的内容会自动出现在 Issue 里面。  </span><br><span class="line"></span><br><span class="line">#### math  </span><br><span class="line"></span><br><span class="line">可能在一些情况下我们需要写一个公式，比如演示一个算法推导过程，MarkDown 是支持公式显示的，Hexo 的 Next 主题同样是支持的。</span><br><span class="line"></span><br><span class="line">Next 主题提供了两个渲染引擎，分别是 mathjax 和 katex，后者相对前者来说渲染速度更快，而且不需要 JavaScript 的额外支持，但后者支持的功能现在还不如前者丰富，具体的对比可以看官方文档：https://theme-next.org/docs/third-party-services/math-equations。</span><br><span class="line"></span><br><span class="line">所以我这里选择了 mathjax，通过修改配置即可启用：</span><br><span class="line"></span><br><span class="line">math:</span><br><span class="line">  enable: true</span><br><span class="line"></span><br><span class="line">  # Default (true) will load mathjax / katex script on demand.</span><br><span class="line">  # That is it only render those page which has `mathjax: true` in Front-matter.</span><br><span class="line">  # If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span><br><span class="line">  per_page: true</span><br><span class="line"></span><br><span class="line">  # hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span><br><span class="line">  mathjax:</span><br><span class="line">    enable: true</span><br><span class="line">    # See: https://mhchem.github.io/MathJax-mhchem/</span><br><span class="line">    mhchem: true  </span><br><span class="line"></span><br><span class="line">mathjax 的使用需要我们额外安装一个插件，叫做 hexo-renderer-kramed，另外也可以安装 hexo-renderer-pandoc，命令如下：  </span><br><span class="line"></span><br><span class="line">npm un hexo-renderer-marked --save</span><br><span class="line">npm i hexo-renderer-kramed --save  </span><br><span class="line"></span><br><span class="line">### 文章 </span><br><span class="line"></span><br><span class="line">我们怎样来增加其他的文章呢？</span><br><span class="line"></span><br><span class="line">这个很简单，只需要调用 Hexo 提供的命令即可，比如我们要新建一篇「HelloWorld」的文章，在source目录下命令如下：  </span><br><span class="line">```hexo new hello-world</span><br></pre></td></tr></table></figure><p>创建的文章会出现在 source/_posts 文件夹下，是 MarkDown 格式。</p><p>在文章开头通过如下格式添加必要信息：  </p><pre><code>---title: 标题 # 自动创建，如 hello-worlddate: 日期 # 自动创建，如 2019-09-22 01:47:21tags: - 标签1- 标签2- 标签3categories:- 分类1- 分类2---</code></pre><p>开头下方撰写正文，MarkDown 格式书写即可。</p><p>这样在下次编译的时候就会自动识别标题、时间、类别等等，另外还有其他的一些参数设置，可以参考文档：<a href="https://hexo.io/zh-cn/docs/writing.html。" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/writing.html。</a>  </p><h3 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p>执行这个命令之后会自动帮我们生成一个 source/tags/index.md 文件，内容就只有这样子的：  </p><pre><code>---title: tagsdate: 2019-09-26 16:44:17---</code></pre><p>我们可以自行添加一个 type 字段来指定页面的类型：  </p><pre><code>type: tagscomments: false  </code></pre><p>然后再在主题的 _config.yml 文件将这个页面的链接添加到主菜单里面，修改 menu 字段如下：</p><pre><code>menu:  home: / || home  #about: /about/ || user  tags: /tags/ || tags  #categories: /categories/ || th  archives: /archives/ || archive  #schedule: /schedule/ || calendar  #sitemap: /sitemap.xml || sitemap  #commonweal: /404/ || heartbeat</code></pre><p>这样重新本地启动看下页面状态，效果如下：  </p><p>可以看到左侧导航也出现了标签，点击之后右侧会显示标签的列表。  </p><h4 id="分类页"><a href="#分类页" class="headerlink" title="分类页"></a>分类页</h4><p>分类功能和标签类似，一个文章可以对应某个分类，如果要增加分类页面可以使用如下命令创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p>然后同样地，会生成一个 source/categories/index.md 文件。</p><p>我们可以自行添加一个 type 字段来指定页面的类型：  </p><pre><code>type: categoriescomments: false</code></pre><p>然后再在主题的 _config.yml 文件将这个页面的链接添加到主菜单里面，修改 menu 字段如下：  </p><pre><code>menu:  home: / || home  #about: /about/ || user  tags: /tags/ || tags  categories: /categories/ || th  archives: /archives/ || archive  #schedule: /schedule/ || calendar  #sitemap: /sitemap.xml || sitemap  #commonweal: /404/ || heartbeat</code></pre><h4 id="搜索页"><a href="#搜索页" class="headerlink" title="搜索页"></a>搜索页</h4><p>很多情况下我们需要搜索全站的内容，所以一个搜索功能的支持也是很有必要的。</p><p>如果要添加搜索的支持，需要先安装一个插件，叫做 hexo-generator-searchdb，命令如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><p>然后在项目的 _config.yml 里面添加搜索设置如下：</p><pre><code>search:  path: search.xml  field: post  format: html  limit: 10000</code></pre><p>然后在主题的 _config.yml 里面修改如下：  </p><pre><code># Local search# Dependencies: https://github.com/wzpan/hexo-generator-searchlocal_search:  enable: true  # If auto, trigger search by changing input.  # If manual, trigger search by pressing enter key or search button.  trigger: auto  # Show top n results per article, show all results by setting to -1  top_n_per_article: 5  # Unescape html strings to the readable one.  unescape: false  # Preload the search data when the page loads.  preload: false</code></pre><p>这里用的是 Local Search，如果想启用其他是 Search Service 的话可以参考官方文档：<a href="https://theme-next.org/docs/third-party-services/search-services。" target="_blank" rel="noopener">https://theme-next.org/docs/third-party-services/search-services。</a>  </p><h3 id="404页面"><a href="#404页面" class="headerlink" title="404页面"></a>404页面</h3><p>另外还需要添加一个 404 页面，直接在根目录 source 文件夹新建一个 404.md 文件即可，内容可以仿照如下：  </p><pre><code>---title: 404 Not Founddate: 2019-10-01 18:57:55---&lt;center&gt;对不起，您所访问的页面不存在或者已删除。您可以&lt;a href=&quot;https://alexxigang.github.io/&gt;&quot;&gt;点击此处&lt;/a&gt;返回首页。&lt;/center&gt;&lt;blockquote class=&quot;blockquote-center&quot;&gt;    alexxigang&lt;/blockquote&gt;</code></pre><p>这里面的一些相关信息和链接可以替换成自己的。</p><p>增加了这个 404 页面之后就可以</p><p>完成了上面的配置基本就完成了大半了，其实 Hexo 还有很多很多功能，这里就介绍不过来了，大家可以直接参考官方文档：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">https://hexo.io/zh-cn/docs/</a> 查看更多的配置。  </p><h3 id="部署脚本"><a href="#部署脚本" class="headerlink" title="部署脚本"></a>部署脚本</h3><p>最后我这边还增加了一个简易版的部署脚本，其实就是重新 gererate 下文件，然后重新部署。在根目录下新建一个 deploy.sh 的脚本文件，内容如下：</p><pre><code>hexo cleanhexo generatehexo deploy</code></pre><p>这样我们在部署发布的时候只需要执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh deploy.sh</span><br></pre></td></tr></table></figure><p>就可以完成博客的更新了，非常简单。  </p><h3 id="发布文章流程"><a href="#发布文章流程" class="headerlink" title="发布文章流程"></a>发布文章流程</h3><blockquote><p>先在source目录(或者根目录)下运行如下命令  </p></blockquote><figure class="highlight plain"><figcaption><span>new '&#123;文章标题&#125;'</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">```  </span><br><span class="line">&gt; 然后在source/_posts下回出现 文章标题.md，编写改文件</span><br><span class="line">&gt; 编写完成后，一次执行如下命令:  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br><span class="line">&gt; 或者执行脚本deploy.sh</span><br></pre></td></tr></table></figure><p>sh deploy.sh<br>```</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;搭建个人博客&quot;&gt;&lt;a href=&quot;#搭建个人博客&quot; class=&quot;headerlink&quot; title=&quot;搭建个人博客&quot;&gt;&lt;/a&gt;搭建个人博客&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;本文是参考大才哥的搭建博客文章所写的供个人备忘的教程  &lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
    
      <category term="教程" scheme="http://yoursite.com/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="http://yoursite.com/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>note_for_java</title>
    <link href="http://yoursite.com/2019/10/01/note-for-java/"/>
    <id>http://yoursite.com/2019/10/01/note-for-java/</id>
    <published>2019-10-01T13:27:16.000Z</published>
    <updated>2019-10-01T13:38:54.137Z</updated>
    
    <content type="html"><![CDATA[<p>java常见面试汇总<br>=</p><p><a href="https://gitee.com/SnailClimb/JavaGuide/tree/master/docs/java" target="_blank" rel="noopener">参考链接：javaguide</a><br><a href="https://snailclimb.gitee.io/javaguide/" target="_blank" rel="noopener">javaguide</a></p><h2 id="某大佬总结的java面试重点"><a href="#某大佬总结的java面试重点" class="headerlink" title="某大佬总结的java面试重点"></a>某大佬总结的java面试重点</h2><p>链接：<a href="https://www.nowcoder.com/discuss/123525" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/123525</a></p><ul><li>Java基础（例如各种集合类，Java的特性，重写重载区别，equals和 hashcode的联系等等）  </li><li>数据库（主要是MySQL，最常问的例如索引，事务隔离级别等等）  </li><li>Spring（IOC,AOP的基础和底层例如cglib，jdk proxy等）  </li><li>计网和<em>*</em>作系统（这个有好多，但是重点的也就那些，比如三次握手四  次挥手，死锁，进程线程区别，线程的生命周期等）  </li><li>并发、JVM、线程池（把深入理解JVM的第2、3、7、最后两章看会感觉就足够  了，还有并发编程的艺术(这本没全看—，但是感觉面试经常问，比如原子 类，并发包工具等）</li><li>算法（面试个人感觉就是剑指offer的难度，遇到了好多原题，但是笔试  就得会贪心动态规划各种了虽然我不怎么会尴尬）</li><li>Redis、微服务（这个如果你简历上写了，面试官才会问，没写一般不  问）</li></ul><h3 id="牛客网汇总"><a href="#牛客网汇总" class="headerlink" title="牛客网汇总"></a>牛客网汇总</h3><ul><li><a href="https://www.nowcoder.com/discuss/94114" target="_blank" rel="noopener">阿里一面问题求指教</a>（阿里面试针对这个复习）  </li><li><a href="https://www.nowcoder.com/questionTerminal/6bd3857199564b3fb2d3fee4f4de06ea?toCommentId=1185246https://www.nowcoder.com/discuss/123525" target="_blank" rel="noopener">Java中的HashMap的工作原理是什么？</a>  </li><li><a href="https://www.nowcoder.com/discuss/97862" target="_blank" rel="noopener">360，阿里，美团，快手，贝壳，猫眼等面经及个人学习记录帖</a>  </li><li><a href="https://snailclimb.gitee.io/javaguide/#/essential-content-for-interview/BATJrealInterviewExperience/5%E9%9D%A2%E9%98%BF%E9%87%8C,%E7%BB%88%E8%8E%B7offer" target="_blank" rel="noopener">阿里五次面试面经</a></li></ul><h4 id="牛客网集锦整理"><a href="#牛客网集锦整理" class="headerlink" title="牛客网集锦整理"></a>牛客网集锦整理</h4><ul><li><a href="https://www.nowcoder.com/discuss/63072?type=post&amp;order=time&amp;pos=&amp;page=0" target="_blank" rel="noopener">后台开发常问面试题集锦（问题搬运工，附链接）</a> </li><li><a href="https://www.nowcoder.com/discuss/205303?type=5" target="_blank" rel="noopener">JAVA面试基础，看完应付9成面试问题</a>  </li><li><a href="https://www.nowcoder.com/discuss/221057?type=2" target="_blank" rel="noopener">面试必会的，一般开发能覆盖9成</a>  </li></ul><h4 id="师兄赠送面经"><a href="#师兄赠送面经" class="headerlink" title="师兄赠送面经"></a>师兄赠送面经</h4><p><a href="https://note.youdao.com/ynoteshare1/index.html?id=8d212c41b0d3f4852e584b7676cfe34b&amp;type=notebook" target="_blank" rel="noopener">师兄赠送面经</a></p><h4 id="亿万级数据处理的高效解决方案"><a href="#亿万级数据处理的高效解决方案" class="headerlink" title="亿万级数据处理的高效解决方案"></a>亿万级数据处理的高效解决方案</h4><ul><li><a href="https://www.nowcoder.com/discuss/150810?type=post&amp;order=time&amp;pos=&amp;page=1" target="_blank" rel="noopener">亿万级数据处理的高效解决方案</a>  </li></ul><h3 id="java中数据类型分为基本数据类型和引用数据类型。"><a href="#java中数据类型分为基本数据类型和引用数据类型。" class="headerlink" title="java中数据类型分为基本数据类型和引用数据类型。"></a>java中数据类型分为基本数据类型和引用数据类型。</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>整型：byte，short，int，long<br>浮点型：float，double<br>字符型：char<br>布尔型：boolean</p><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><p>数组<br>类<br>接口  </p><h4 id="Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按-值传递的"><a href="#Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按-值传递的" class="headerlink" title="Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按 值传递的"></a>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按 值传递的</h4><h3 id="在-Java-中定义一个不做事且没有参数的构造方法的作用"><a href="#在-Java-中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="在 Java 中定义一个不做事且没有参数的构造方法的作用"></a>在 Java 中定义一个不做事且没有参数的构造方法的作用</h3><p>Java 程序在执行子类的构造方法之前，如果没有用 super()来调用父类特  定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中  只定义了有参数的构造方法，而在子类的构造方法中又没有用 super()来  调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类  中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做  事且没有参数的构造方法。 　</p><h3 id="创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>创建一个对象用什么运算符?对象实体与对象引用有何不同?</h3><p>new运算符，new创建对象实例（对象实例在堆内存中），对象引用指向对象  实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象  （一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指  向它（可以用n条绳子系住一个气球）。  </p><h3 id="关于-final-关键字的一些总结"><a href="#关于-final-关键字的一些总结" class="headerlink" title="关于 final 关键字的一些总结"></a>关于 final 关键字的一些总结</h3><p>final关键字主要用在三个地方：变量、方法、类。<br>对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化  之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让  其指向另一个对象。<br>当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方  法都会被隐式地指定为final方法。<br>使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修  改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方  法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何  性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。  类中所有的private方法都隐式地指定为final。  </p><h3 id="为什么TCP客户端最后还要发送一次确认呢？"><a href="#为什么TCP客户端最后还要发送一次确认呢？" class="headerlink" title="为什么TCP客户端最后还要发送一次确认呢？"></a>为什么TCP客户端最后还要发送一次确认呢？</h3><p><strong>一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</strong><br>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一  个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于    TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服  务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数  据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服  务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务  器再次建立连接，这将导致不必要的错误和资源的浪费。<br>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受  到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由  于服务器收不到确认，就知道客户端并没有请求连接。<br><img src="https://img-blog.csdn.net/20170605110405666?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXpjc3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="三次握手">  </p><h3 id="为什么在四次挥手客户端最后还要等待2MSL？"><a href="#为什么在四次挥手客户端最后还要等待2MSL？" class="headerlink" title="为什么在四次挥手客户端最后还要等待2MSL？"></a>为什么在四次挥手客户端最后还要等待2MSL？</h3><p>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同  的MSL值。<br>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报  文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开  了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于  是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重  传的报文，接着给出回应报文，并且会重启2MSL计时器。<br>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现  在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可  以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连  接中不会出现旧连接的请求报文。  </p><h3 id="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"></a>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h3><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文  后，把ACK和SYN放在一个报文里发送给客户端。<br>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，<strong>也可以发送一些数据给对方后</strong>，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。  </p><h3 id="四-TCP-协议如何保证可靠传输"><a href="#四-TCP-协议如何保证可靠传输" class="headerlink" title="四 TCP 协议如何保证可靠传输"></a>四 TCP 协议如何保证可靠传输</h3><ul><li>应用数据被分割成 TCP 认为最适合发送的数据块。  </li><li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传  送给应用层。  </li><li>校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。  </li><li>TCP的接收端会丢弃重复的数据。  </li><li>流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只  允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的  数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协  议是可变大小的滑动窗口协议。<strong>（TCP 利用滑动窗口实现流量控制）</strong></li><li>拥塞控制： 当网络拥塞时，减少数据的发送。  </li><li>ARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就  停止发送，等待对方确认。在收到确认后再发下一个分组。  </li><li>超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收  到这个报文段。如果不能及时收到一个确认，将重发这个报文段。<br><img src="https://img-blog.csdn.net/20170607205756255?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXpjc3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="三次握手"></li></ul><h3 id="五-接口与抽象的异同"><a href="#五-接口与抽象的异同" class="headerlink" title="五.接口与抽象的异同"></a>五.接口与抽象的异同</h3><h4 id="1-抽象类"><a href="#1-抽象类" class="headerlink" title="1.抽象类"></a>1.抽象类</h4><p>抽象类是关键字abstract修饰的类，既为抽象类，抽象抽象即不能被实例化。而不能被实例化就无用处，所以抽象类只能作为基类（父类），即被继承的类。抽象类中可以包含抽象方法也可以不包含，但具有抽象方法的类一定是抽象类。<br>　　抽象类的使用原则如下：</p><p>（1）被继承性：抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public；<br>（2）<strong>抽象性</strong>：抽象类不能直接实例化，需要依靠子类采用向上转型的方式处理；<br>（3）抽象类必须有子类，使用extends继承，一个子类只能继承一个抽象类；<br>（4）子类（如果不是抽象类）则<strong>必须覆写抽象类之中的全部抽象方法</strong>（如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。  </p><h4 id="1、接口与类相似点"><a href="#1、接口与类相似点" class="headerlink" title="1、接口与类相似点"></a>1、接口与类相似点</h4><p>一个接口可以有多个方法。<br>接口文件保存在 .java 结尾的文件中，文件名使用接口名。<br>接口的字节码文件保存在 .class 结尾的文件中。<br>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</p><h4 id="2、接口与类的区别"><a href="#2、接口与类的区别" class="headerlink" title="2、接口与类的区别"></a>2、接口与类的区别</h4><p>接口不能用于实例化对象。<br>接口没有构造方法。<br>接口中所有的方法必须是抽象方法。<br>接口不能包含成员变量，除了 static 和 final 变量。<br>接口不是被类继承了，而是要被类实现。<br>接口支持多继承。</p><h4 id="3、接口特性"><a href="#3、接口特性" class="headerlink" title="3、接口特性"></a>3、接口特性</h4><p>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。<br>接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。<br>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。<br><img src="https://i.imgur.com/28uQkav.png" alt="接口与抽象类异同"><br><img src="https://i.imgur.com/mxRbvpg.png" alt></p><h3 id="六-static关键字"><a href="#六-static关键字" class="headerlink" title="六.static关键字"></a>六.static关键字</h3><ul><li>static关键字并不会改变变量和方法的访问权限。 与C/C++中的static不同，Java中的static关键字不会影响到变量或者方法的作用域。在Java中能够影响到访问权限的只有private、public、protected（包括包访问权限）这几个关键字。   </li><li>为什么说static块可以用来优化程序性能，是因为它的特性:只会在<strong>类加载的时候</strong>执行一次。 很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行 </li><li>static成员变量的初始化顺序按照定义的顺序进行初始化。  </li><li>即使没有显示地声明为static，<strong>类的构造器实际上也是静态方法</strong>。  </li><li>static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。  </li><li><ul><li>static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，<strong>JVM加载类时会执行这些静态的代码块</strong>，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。</li></ul></li><li>普通类是不允许声明为静态的，只有内部类才可以。</li></ul><p>被static修饰的内部类可以直接作为一个普通类来使用，而不需实例一个外部类  </p><ul><li>static能作用于局部变量么？</li></ul><p>　　在C/C++中static是可以作用域局部变量的，但是在Java中切记：<strong>static是不允许用来修饰局部变量</strong>。不要问为什么，这是Java语法的规定。  </p><ul><li>常见的笔试面试题    </li></ul><ol><li><p> public class Test extends Base{</p><p>  static{</p><pre><code> System.out.println(&quot;test static&quot;);</code></pre><p> }</p><p> public Test(){</p><pre><code> System.out.println(&quot;test constructor&quot;);</code></pre><p> }</p><p> public static void main(String[] args) {</p><pre><code> new Test();</code></pre><p> }<br> }</p><p>  class Base{</p><p> static{</p><pre><code> System.out.println(&quot;base static&quot;);</code></pre><p> }</p><p> public Base(){</p><pre><code> System.out.println(&quot;base constructor&quot;);</code></pre><p> }<br> }  </p></li></ol><p>输出：<br>        base static<br>         test static<br>         base constructor<br>         test constructor    </p><p>先来想一下这段代码具体的执行过程，在执行开始，先要寻找到main方法，因为main方法是程序的入口，但是在执行main方法之前，必须先加载Test类，而在加载Test类的时候发现Test类继承自Base类，因此会转去先加载Base类，在加载Base类的时候，发现有static块，便执行了static块。在Base类加载完成之后，便继续加载Test类，然后发现Test类中也有static块，便执行static块。在加载完所需的类之后，便开始执行main方法。在main方法中执行new Test()的时候会先调用父类的构造器，然后再调用自身的构造器。因此，便出现了上面的输出结果。</p><ul><li><p>static块可以出现类中的任何地方（只要不是方法内部，记住，任何方法内部都不行），并且执行是按照static块的顺序执行的。</p></li><li><p>这段代码的输出结果是什么？  </p><pre><code>    public class Test {    Person person = new Person(&quot;Test&quot;);    static{      System.out.println(&quot;test static&quot;);    }</code></pre></li></ul><pre><code>    public Test() {          System.out.println(&quot;test constructor&quot;);        }      public static void main(String[] args) {          new MyClass();      }}   class Person{        static{          System.out.println(&quot;person static&quot;);      }    public Person(String str) {  `        System.out.println(&quot;person &quot;+str);      }}   class MyClass extends Test {      Person person = new Person(&quot;MyClass&quot;);      static{          System.out.println(&quot;myclass static&quot;);      }    public MyClass() {          System.out.println(&quot;myclass constructor&quot;);      }   }     </code></pre><p>输出：</p><pre><code>` test static ` ` myclass static ` ` person static  `` person Test`` test constructor`` person MyClass`` myclass constructor`</code></pre><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>首先加载Test类，因此会执行Test类中的static块。接着执行new MyClass()，而MyClass类还没有被加载，因此需要加载MyClass类。在加载MyClass类的时候，发现MyClass类继承自Test类，但是由于Test类已经被加载了，所以只需要加载MyClass类，那么就会执行MyClass类的中的static块。在加载完之后，就通过构造器来生成对象。而在生成对象的时候，<strong><em>必须先初始化父类的成员变量</em></strong>，因此会执行Test中的Person person = new Person()，而Person类还没有被加载过，因此会先加载Person类并执行Person类中的static块，接着执行父类的构造器，完成了父类的初始化，然后就来初始化自身了，因此会接着执行MyClass中的Person person = new Person()，最后执行MyClass的构造器。</p><h3 id="七-final"><a href="#七-final" class="headerlink" title="七.final"></a>七.final</h3><ul><li>根据程序上下文环境，Java关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类成员方法和变量。你可能出于两种理解而需要阻止改变：设计或效率。<pre><code>  final类不能被继承，没有子类，final类中的方法默认是final的。  final方法不能被子类的方法覆盖，但可以被继承。  final成员变量表示常量，只能被赋值一次，赋值后值不再改变。  final不能用于修饰构造方法。  注意：父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的。</code></pre></li><li>final类不能被继承，因此final类的成员方法没有机会被覆盖，默认都是final的。在设计类时候，如果这个类不需要有子类，类的实现细节不允许改变，并且确信这个类不会载被扩展，那么就设计为final类。</li><li>final方法<pre><code>  如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为final方法。  使用final方法的原因有二：  第一、把方法锁定，防止任何继承类修改它的意义和实现。  第二、高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。</code></pre></li><li><p>final变量（常量）</p><pre><code>  用final修饰的成员变量表示常量，值一旦给定就无法改变！  final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。  从下面的例子中可以看出，一旦给final变量初值后，值就不能再改变了。  另外，final变量定义的时候，可以先声明，而不给初值，这中变量也称为final空白，无论什么情况，编译器都确保空白final在使用之前必须被初始化。但是，final空白在final关键字final的使用上提供了更大的灵活性，为此，一个类中的final数据成员就可以实现依对象而有所不同，却有保持其恒定不变的特征。</code></pre></li><li><p>static和final一块用表示什么</p><pre><code>  static final用来修饰成员变量和成员方法，可简单理解为“全局常量”！  对于变量，表示一旦给值就不可修改，并且通过类名可以访问。  对于方法，表示不可覆盖，并且可以通过类名直接访问。  ** 特别要注意一个问题： **  对于被static和final修饰过的实例常量，实例本身不能再改变了，但**对于一些容器类型（比如，ArrayList、HashMap）的实例变量，不可以改变容器变量本身，但可以修改容器中存放的对象，**这一点在编程中用到很多。</code></pre></li></ul><h3 id="八-Java关键字this、super使用总结"><a href="#八-Java关键字this、super使用总结" class="headerlink" title="八.Java关键字this、super使用总结"></a>八.Java关键字this、super使用总结</h3><h4 id="一、this"><a href="#一、this" class="headerlink" title="一、this"></a>一、this</h4><p>Java关键字this只能用于方法方法体内。当一个对象创建后，<br>Java虚拟机（JVM）就会给这个对象分配一个引用自身的指针，这个指针的名字就是this。因此，this只能在类中的非静态方法中使用，静态方法和静态的代码块中绝对不能出现this，这在“Java关键字static、final使用总结”一文中给出了明确解释。并且this只和特定的对象关联，而不和类关联，同一个类的不同对象有不同的this。  </p><ul><li><p>在什么情况下需要用到this：</p><pre><code>  第一、通过this调用另一个构造方法，用发是this(参数列表)，这个仅仅在类的构造方法中，别的地方不能这么用。  第二、函数参数或者函数中的局部变量和成员变量同名的情况下，成员变量被屏蔽，此时要访问成员变量则需要用“this.成员变量名”的方式来引用成员变量。当然，在没有同名的情况下，可以直接用成员变量的名字，而不用this，用了也不为错，呵呵。  第三、在函数中，需要引用该函所属类的当前对象时候，直接用this。</code></pre><h4 id="二、super"><a href="#二、super" class="headerlink" title="二、super"></a>二、super</h4><pre><code>  super关键和this作用类似，是被屏蔽的成员变量或者成员方法  或变为可见，或者说用来引用被屏蔽的成员变量和成员成员方法。</code></pre><p>不过super是用在子类中，目的是访问直接父类中被屏蔽的成员，注意是直接父类（就是类之上最近的超类）。  </p></li><li><p>总结一下super的用法：</p><pre><code>  第一、在子类构造方法中要调用父类的构造方法，用“super(参数列表)”的方式调用，参数不是必须的。同时还要注意的一点是：**“super(参数列表)”这条语句只能用在子类构造方法体中的第一行。**  第二、当子类方法中的局部变量或者子类的成员变量与父类成员变量同名时，也就是子类局部变量覆盖父类成员变量时，用“super.成员变量名”来引用父类成员变量。当然，如果父类的成员变量没有被覆盖，也可以用“super.成员变量名”来引用父类成员变量，不过这是不必要的。  第三、当子类的成员方法覆盖了父类的成员方法时，也就是子类和父类有完全相同的方法定义（但方法体可以不同），此时，用“super.方法名(参数列表)”的方式访问父类的方法。  </code></pre><h3 id="九-java中的匿名内部类总结"><a href="#九-java中的匿名内部类总结" class="headerlink" title="九.java中的匿名内部类总结"></a>九.java中的匿名内部类总结</h3><p>匿名内部类也就是没有名字的内部类</p></li></ul><p>正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写</p><p>但使用匿名内部类还有个<strong>前提条件：必须继承一个父类或实现一个接口</strong>  </p><h4 id="匿名内部类的基本实现"><a href="#匿名内部类的基本实现" class="headerlink" title="匿名内部类的基本实现"></a>匿名内部类的基本实现</h4><pre><code>abstract class Person {public abstract void eat();}public class Demo {public static void main(String[] args) {    Person p = new Person() {        public void eat() {            System.out.println(&quot;eat something&quot;);        }    };    p.eat();}}  </code></pre><p>可以看到，我们直接将抽象类Person中的方法在大括号中实现了</p><p>这样便可以省略一个类的书写</p><p>并且，匿名内部类还能用于接口上</p><h4 id="在接口上使用匿名内部类"><a href="#在接口上使用匿名内部类" class="headerlink" title="在接口上使用匿名内部类"></a>在接口上使用匿名内部类</h4><pre><code>interface Person {public void eat();}public class Demo {public static void main(String[] args) {    Person p = new Person() {        public void eat() {            System.out.println(&quot;eat something&quot;);        }    };    p.eat();}}  </code></pre><p>由上面的例子可以看出，只要一个类是抽象的或是一个接口，那么其子类中的方法都可以使用匿名内部类来实现</p><p>最常用的情况就是在多线程的实现上，因为要实现多线程必须继承Thread类或是继承Runnable接口</p><h4 id="Thread类的匿名内部类实现"><a href="#Thread类的匿名内部类实现" class="headerlink" title="Thread类的匿名内部类实现"></a>Thread类的匿名内部类实现</h4><pre><code>public class Demo {public static void main(String[] args) {    Thread t = new Thread() {        public void run() {            for (int i = 1; i &lt;= 5; i++) {                System.out.print(i + &quot; &quot;);            }        }    };    t.start();}}  </code></pre><h4 id="Runnable接口的匿名内部类实现"><a href="#Runnable接口的匿名内部类实现" class="headerlink" title="Runnable接口的匿名内部类实现"></a>Runnable接口的匿名内部类实现</h4><pre><code>public class Demo {public static void main(String[] args) {    Runnable r = new Runnable() {        public void run() {            for (int i = 1; i &lt;= 5; i++) {                System.out.print(i + &quot; &quot;);            }        }    };    Thread t = new Thread(r);    t.start();}}  </code></pre><h3 id="垃圾回收算法原理"><a href="#垃圾回收算法原理" class="headerlink" title="垃圾回收算法原理"></a>垃圾回收算法原理</h3><p>转载自：<a href="https://blog.csdn.net/FateRuler/article/details/81158510" target="_blank" rel="noopener">https://blog.csdn.net/FateRuler/article/details/81158510</a> </p><h4 id="第一种：标记清除"><a href="#第一种：标记清除" class="headerlink" title="第一种：标记清除"></a>第一种：标记清除</h4><p>它是最基础的收集算法。<br>原理：分为标记和清除两个阶段：首先标记出所有的需要回收的对象，在标记完成以后统一回收所有被标记的对象。<br>特点：（1）效率问题，标记和清除的效率都不高；（2）空间的问题，标记清除以后会产生大量不连续的空间碎片，空间碎片太多可能会导致程序运行过程需要分配较大的对象时候，无法找到足够连续内存而不得不提前触发一次垃圾收集。<br>地方 ：适合在老年代进行垃圾回收，比如CMS收集器就是采用该算法进行回收的。</p><h4 id="第二种：标记整理"><a href="#第二种：标记整理" class="headerlink" title="第二种：标记整理"></a>第二种：标记整理</h4><p>原理：分为标记和整理两个阶段：首先标记出所有需要回收的对象，让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。<br>特点：不会产生空间碎片，但是整理会花一定的时间。<br>地方：适合老年代进行垃圾收集，parallel Old（针对parallel scanvange gc的） gc和Serial old收集器就是采用该算法进行回收的。</p><h4 id="第三种：复制算法"><a href="#第三种：复制算法" class="headerlink" title="第三种：复制算法"></a>第三种：复制算法</h4><p>原理：它先将可用的内存按容量划分为大小相同的两块，每次只是用其中的一块。当这块内存用完了，就将还存活着的对象复制到另一块上面，然后把已经使用过的内存空间一次清理掉。<br>特点：没有内存碎片，只要移动堆顶指针，按顺序分配内存即可。代价是将内存缩小位原来的一半。<br>地方：适合新生代区进行垃圾回收。serial new，parallel new和parallel scanvage<br>收集器，就是采用该算法进行回收的。</p><h4 id="复制算法改进思路："><a href="#复制算法改进思路：" class="headerlink" title="复制算法改进思路："></a>复制算法改进思路：</h4><p>由于新生代都是朝生夕死的，所以不需要1：1划分内存空间，可以将内存划分为一块较大的Eden和两块较小的Suvivor空间。每次使用Eden和其中一块Survivor。当回收的时候，将Eden和Survivor中还活着的对象一次性地复制到另一块Survivor空间上，最后清理掉Eden和刚才使用过的Suevivor空间。其中Eden和Suevivor的大小比例是8：1。缺点是需要老年代进行分配担保，如果第二块的Survovor空间不够的时候，需要对老年代进行垃圾回收，然后存储新生代的对象，这些新生代当然会直接进入来老年代。</p><p>优化收集方法的思路<br>分代收集算法<br>原理：根据对象存活的周期的不同将内存划分为几块，然后再选择合适的收集算法。<br>一般是把java堆分成新生代和老年代，这样就可以根据各个年待的特点采用最适合的收集算法。在新生代中，每次垃圾收集都会有大量的对象死去，只有少量存活，所以选用复制算法。老年代因为对象存活率高，没有额外空间对他进行分配担保，所以一般采用标记整理或者标记清除算法进行回收。</p><p>对于以上两种标记算法存在争议，在深入了解JVM最佳实践第二版中，是写的标记需要回收的对象，我也没太深入思考，直到有人提出来，我也去查了一下和想了一下。我个人现在偏向，标记存活的对象。<br><strong>标记算法的大概流程：通过引用链给所有存活的对象做个标记，然后回收所有没有标记的对象 和 清除存活对象的标记，等待下一次GC</strong></p><h3 id="GC用的引用可达性分析算法中，哪些对象可作为GC-Roots对象"><a href="#GC用的引用可达性分析算法中，哪些对象可作为GC-Roots对象" class="headerlink" title="GC用的引用可达性分析算法中，哪些对象可作为GC Roots对象"></a>GC用的引用可达性分析算法中，哪些对象可作为GC Roots对象</h3><p>先说一下可达性分析算法的思想：从一个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。</p><h4 id="在java中可以作为GC-Roots的对象有以下几种："><a href="#在java中可以作为GC-Roots的对象有以下几种：" class="headerlink" title="在java中可以作为GC Roots的对象有以下几种："></a>在java中可以作为GC Roots的对象有以下几种：</h4><p>转载自：<a href="https://blog.csdn.net/ma345787383/article/details/77099522" target="_blank" rel="noopener">https://blog.csdn.net/ma345787383/article/details/77099522</a> </p><p>虚拟机栈中引用的对象、方法区类静态属性引用的对象、方法区常量池引用的对象、本地方法栈JNI引用的对象<br>虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象 <strong>不一定会被回收。</strong>当一个对象不可达GC Roots时，这个对象并不会马上被回收，而是处于一个死缓的阶段，<strong>若要被真正的回收需要经历两次标记。</strong>如果对象在可达性分析中没有与GC Roots的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行finalize()方法。当对象没有覆盖finalize()方法或者已经被虚拟机调用过，那么就认为是没必要的。<br>如果该对象有必要执行finalize()方法，那么这个对象将会放在一个称为F-Queue的队列中，虚拟机会触发一个finalize()线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这还是因为如果finalize()执行缓慢或者发生了死锁，那么就会造成F-Queue队列一直等待，造成了内存回收系统的崩溃。GC对处于F-Queue中的对象进行第二次被标记，这时，该对象将被移除“即将回收”集合，等待回收。</p><h3 id="hashmap中key是否可以为null"><a href="#hashmap中key是否可以为null" class="headerlink" title="hashmap中key是否可以为null"></a>hashmap中key是否可以为null</h3><p>1、 HashMap计算key的hash值时调用单独的方法，在该方法中会判断key是否为null，如果是则返回0；而Hashtable中则直接调用key的hashCode()方法，因此如果key为null，则抛出空指针异常。</p><p>2、 HashMap将键值对添加进数组时，不会主动判断value是否为null；而Hashtable则首先判断value是否为null。</p><p>3、以上原因主要是由于Hashtable继承自Dictionary，而HashMap继承自AbstractMap。</p><p>4、虽然ConcurrentHashMap也继承自AbstractMap，但是其也过滤掉了key或value为null的键值对。  </p><ul><li>JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过<strong>(n - 1) &amp; hash</strong> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</li></ul><p>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</p><h3 id="十-基本数据类型和对象的区别"><a href="#十-基本数据类型和对象的区别" class="headerlink" title="十.基本数据类型和对象的区别"></a>十.基本数据类型和对象的区别</h3><p>(1) 基本数据类型的存储原理：所有的简单数据类型不存在“引用”的概念，基本数据类型都是直接存储在内存中的栈上的，数据本身的值就是存储在栈空间里面，Java语言里面八种数据类型是这种存储模型；</p><p>(2) 引用类型的存储原理：引用类型继承于Object类（也是引用类型）都是按照Java里面存储对象的内存模型来进行数据存储的，使用Java堆和栈来进行这种类型的数据存储，简单地讲，“引用”(存储对象在内存堆上的地址)是存储在有序的栈上的，而对象本身的值存储在堆上的；</p><p>不论是基本数据类型还是引用类型，他们都会先在栈中分配一块内存，对于基本类型来说，这块区域包含的是基本类型的内容；而对于引用类型来说，这块区域包含的是指向真正内容的指针，真正的内容被手动的分配在堆上。  </p><h3 id="Synchronized的使用"><a href="#Synchronized的使用" class="headerlink" title="Synchronized的使用"></a>Synchronized的使用</h3><h4 id="synchronized的三种应用方式"><a href="#synchronized的三种应用方式" class="headerlink" title="synchronized的三种应用方式"></a>synchronized的三种应用方式</h4><p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础： </p><ol><li>普通同步方法（实例方法），锁是当前实例对象 ，进入同步代码前要获得当前实例的锁   </li><li>静态同步方法，锁是当前类的class对象 ，进入同步代码前要获得当前类对象的锁   </li><li>同步方法块，锁是<strong>括号里面的对象</strong>，对给定对象加锁，进入同步代码库前要获得给定对象的锁。   <h4 id="一个类中存在一个synchronized修饰的方法和一个普通的方法，不同线程同时访问这两个方法，会出现什么情况？"><a href="#一个类中存在一个synchronized修饰的方法和一个普通的方法，不同线程同时访问这两个方法，会出现什么情况？" class="headerlink" title="一个类中存在一个synchronized修饰的方法和一个普通的方法，不同线程同时访问这两个方法，会出现什么情况？"></a>一个类中存在一个synchronized修饰的方法和一个普通的方法，不同线程同时访问这两个方法，会出现什么情况？</h4></li></ol><ul><li><p>一个线程持有对象锁，另一个线程可以以异步的方式调用对象里面的非synchronized方法，输出结果是不按照顺序的</p></li><li><p>一个线程持有对象锁，另一个线程可以以同步的方式调用对象里面的synchronized方法，需要等待上一个线程释放资源，也就是同步。  </p></li><li>两个线程访问不同对象中不同的synchronized方法不会受到synchronized的限制  <h3 id="Java常见的几种内存溢出及解决方案"><a href="#Java常见的几种内存溢出及解决方案" class="headerlink" title="Java常见的几种内存溢出及解决方案"></a>Java常见的几种内存溢出及解决方案</h3></li><li><p>1.JVM Heap（堆）溢出：java.lang.OutOfMemoryError: Java heap space</p><p>   JVM在启动的时候会自动设置JVM Heap的值， 可以利用JVM提供的-Xmn -Xms -Xmx等选项可进行设置。Heap的大小是Young Generation 和Tenured Generaion 之和。在JVM中如果98%的时间是用于GC,且可用的Heap size 不足2%的时候将抛出此异常信息。<br>解决方法：手动设置JVM Heap（堆）的大小。<br>Java堆用于储存对象实例。当需要为对象实例分配内存，而堆的内存占用又已经达到-Xmx设置的最大值。将会抛出OutOfMemoryError异常。  </p></li><li>2.PermGen space溢出： java.lang.OutOfMemoryError: PermGen space<br>   PermGen space的全称是Permanent Generation space，是指内存的永久保存区域。为什么会内存溢出，这是由于这块内存主要是被JVM存放Class和Meta信息的，Class在被Load的时候被放入PermGen space区域，它和存放Instance的Heap区域不同，sun的 GC不会在主程序运行期对PermGen space进行清理，所以如果你的APP会载入很多CLASS的话，就很可能出现PermGen space溢出。一般发生在程序的启动阶段。<br>解决方法： 通过-XX:PermSize和-XX:MaxPermSize设置永久代大小即可。<br>   方法区用于存放java类型的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。在类装载器加载class文件到内存的过程中，虚拟机会提取其中的类型信息，并将这些信息存储到方法区。当需要存储类信息而方法区的内存占用又已经达到-XX:MaxPermSize设置的最大值，将会抛出OutOfMemoryError异常。  </li><li>3.栈溢出： java.lang.StackOverflowError : Thread Stack space<pre><code>栈溢出了，JVM依然是采用栈式的虚拟机，这个和C和Pascal都是一样的。函数的调用过程都体现在堆栈和退栈上了。调用构造函数的 “层”太多了，以致于把栈区溢出了。 通常来讲，一般栈区远远小于堆区的，因为函数调用过程往往不会多于上千层，而即便每个函数调用需要 1K的空间（这个大约相当于在一个C函数内声明了256个int类型的变量），那么栈区也不过是需要1MB的空间。通常栈的大小是1-2MB的。通俗一点讲就是单线程的程序需要的内存太大了。 通常递归也不要递归的层次过多，很容易溢出。</code></pre>解决方法：1：修改程序。2：通过 -Xss: 来设置每个线程的Stack大小即可。<br>在Java虚拟机规范中，对这个区域规定了两种异常状况：StackOverflowError和OutOfMemoryError异常。</li></ul><ul><li><p>（1）StackOverflowError异常</p><pre><code> 每当java程序代码启动一个新线程时，Java虚拟机都会为它分配一个Java栈。Java栈以帧为单位保存线程的运行状态。当线程调用java方法时，虚拟机压入一个新的栈帧到该线程的java栈中。只要这个方法还没有返回，它就一直存在。如果线程的方法嵌套调用层次太多(如递归调用)，随着java栈中帧的逐渐增多，最终会由于该线程java栈中所有栈帧大小总和大于-Xss设置的值，而产生StackOverflowError内存溢出异常。  </code></pre><p>（2）OutOfMemoryError异常<br>  java程序代码启动一个新线程时，没有足够的内存空间为该线程分配java    栈(一个线程java栈的大小由-Xss参数确定)，jvm则抛出OutOfMemoryError异常。  </p></li></ul><ul><li>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。<br>•    StackOverFlowError： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 异常。<br>•    OutOfMemoryError： 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 异常。</li></ul><h3 id="十一-内存泄漏"><a href="#十一-内存泄漏" class="headerlink" title="十一.内存泄漏"></a>十一.内存泄漏</h3><ul><li>内存泄漏与内存溢出的关系：  <pre><code>内存泄漏的堆积最终会导致内存溢出</code></pre>  内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系  统相当于没法满足你的需求，就会报内存溢出的错误。<br>  内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以  后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问  （也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的  程序。就相当于你租了个带钥匙的柜子，你存完东西之后把柜子锁上之  后，把钥匙丢了或者没有将钥匙还回去，那么结果就是这个柜子将无法  供给任何人使用，也无法被垃圾回收器回收，因为找不到他的任何信  息。<br>  内存溢出：一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉  倒地上不能吃了。这就是溢出。比方说栈，栈满时再做进栈必定产生空  间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分  配的内存不足以放下数据项序列,称为内存溢出。说白了就是我承受不了  那么多，那我就报错，  <h4 id="内存泄漏的几种情况："><a href="#内存泄漏的几种情况：" class="headerlink" title="内存泄漏的几种情况："></a>内存泄漏的几种情况：</h4></li><li>1、<strong>静态集合类</strong>，如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。</li><li>2、<strong>各种连接</strong>，如数据库连接、网络连接和IO连接等。在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。</li><li><p>3、<strong>变量不合理的作用域</strong>。一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生。  </p><pre><code>  public class UsingRandom {      private String msg;      public void receiveMsg(){          readFromNet();// 从网络中接受数据保存到msg中          saveDB();// 把msg保存到数据库中      }  }  </code></pre><p>如上面这个伪代码，通过readFromNet方法把接受的消息保存在变量msg  中，然后调用saveDB方法把msg的内容保存到数据库中，此时msg已经就没  用了，由于msg的生命周期与对象的生命周期相同，此时msg还不能回收，因  此造成了内存泄漏。<br>实际上这个msg变量可以放在receiveMsg方法内部，当方法使用完，那么  msg的生命周期也就结束，此时就可以回收了。还有一种方法，在使用完msg  后，把msg设置为null，这样垃圾回收器也会回收msg的内存空间。  </p></li><li>4、内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。</li><li>5、改变哈希值，当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露  <h3 id="Java中常见的几种RuntimeException"><a href="#Java中常见的几种RuntimeException" class="headerlink" title="Java中常见的几种RuntimeException"></a>Java中常见的几种RuntimeException</h3><h4 id="JAVA中常见的几种RuntimeException-大约有如下几种："><a href="#JAVA中常见的几种RuntimeException-大约有如下几种：" class="headerlink" title="JAVA中常见的几种RuntimeException,大约有如下几种："></a>JAVA中常见的几种RuntimeException,大约有如下几种：</h4>NullPointerException - 空指针引用异常<br>ClassCastException - 类型强制转换异常。<br>IllegalArgumentException - 传递非法参数异常。<br>ArithmeticException - 算术运算异常<br>ArrayStoreException - 向数组中存放与声明类型不兼容对象异常<br>IndexOutOfBoundsException - 下标越界异常<br>NegativeArraySizeException - 创建一个大小为负数的数组错误异常<br>NumberFormatException - 数字格式异常<br>SecurityException - 安全异常<br>UnsupportedOperationException - 不支持的操作异常    <h4 id="常见的RuntimeException"><a href="#常见的RuntimeException" class="headerlink" title="常见的RuntimeException"></a>常见的RuntimeException</h4>RuntimeException是开发中最容易遇到的，下面列举一下常见的RuntimeException：    </li></ul><ul><li>1、NullPointerException：见的最多了，其实很简单，一般都是在null对象上调用方法了。  <pre><code>        String s=null;  boolean eq=s.equals(&quot;&quot;); // NullPointerException   </code></pre> 这里你看的非常明白了，为什么一到程序中就晕呢？  <pre><code> public int getNumber(String str){</code></pre>  　　if(str.equals(“A”)) return 1;<br>  　　 else if(str.equals(“B”)) return 2;<pre><code> }  </code></pre> 这个方法就有可能抛出NullPointerException,我建议你主动抛出异常，因为代码一多，你可能又晕了。<br> public int getNumber(String str){<br>　　if(str==null) throw new NullPointerException(“参数不能为空”);<pre><code>                             //你是否觉得明白多了</code></pre>　　if(str.equals(“A”)) return 1;<br>　　    else if(str.equals(“B”)) return 2;<br> }   </li><li>2、NumberFormatException：继承IllegalArgumentException，字符串转换为数字时出现。比如int i= Integer.parseInt(“ab3”);  </li><li>3、ArrayIndexOutOfBoundsException:数组越界。比如 int[] a=new int[3]; int b=a[3];  </li><li>4、StringIndexOutOfBoundsException：字符串越界。比如 String s=”hello”; char c=s.chatAt(6);  </li><li>5、ClassCastException:类型转换错误。比如 Object obj=new Object(); String s=(String)obj;  </li><li>6、UnsupportedOperationException:该操作不被支持。如果我们希望不支持这个方法，可以抛出这个异常。既然不支持还要这个干吗？有可能子类中不想支持父类中有的方法，可以直接抛出这个异常。  </li><li>7、ArithmeticException：算术错误，典型的就是0作为除数的时候。  </li><li>8、IllegalArgumentException：非法参数，在把字符串转换成数字的时候经常出现的一个异常，我们可以在自己的程序中好好利用这个异常。</li></ul><h3 id="java中hashmap的原理"><a href="#java中hashmap的原理" class="headerlink" title="java中hashmap的原理"></a>java中hashmap的原理</h3><h4 id="较详细链接（评论里也有详细解答）"><a href="#较详细链接（评论里也有详细解答）" class="headerlink" title="较详细链接（评论里也有详细解答）"></a>较详细链接（评论里也有详细解答）</h4><p><a href="https://www.nowcoder.com/questionTerminal/6bd3857199564b3fb2d3fee4f4de06ea?toCommentId=1185246" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/6bd3857199564b3fb2d3fee4f4de06ea?toCommentId=1185246</a><br>链接：<a href="https://www.nowcoder.com/questionTerminal/6bd3857199564b3fb2d3fee4f4de06ea?toCommentId=1185246" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/6bd3857199564b3fb2d3fee4f4de06ea?toCommentId=1185246</a><br>来源：牛客网</p><p>hashmap是一个key-value键值对的数据结构，从结构上来讲在jdk1.8之  前是用数组加链表的方式实现，jdk1.8加了红黑树，hashmap数组的默认初  始长度是16，hashmap数组只允许一个key为null，允许多个value为null<br>hashmap的内部实现，hashmap是使用数组+链表+红黑树的形式实现的，  其中数组是一个一个Node[]数组，我们叫他hash桶数组，它上面存放的是  key-value键值对的节点。HashMap是用hash表来存储的，在hashmap里  为解决hash冲突，使用链地址法，简单来说就是数组加链表的形式来解决  ，当数据被hash后，得到数组下标，把数据放在对应下表的链表中。<br>然后再说一下hashmap的方法实现<br>put方法，put方法的第一步，就是计算出要put元素在hash桶数组中的索引  位置，得到索引位置需要三步，去put元素key的hashcode值，高位运算，  取模运算，高位运算就是用第一步得到的值h，用h的高16位和低16位进行异  或操作，第三步为了使hash桶数组元素分布更均匀，采用取模运算，取模运  算就是用第二步得到的值和hash桶数组长度-1的值取与。这样得到的结果和  传统取模运算结果一致，而且效率比取模运算高<br>jdk1.8中put方法的具体步骤，先判断hashmap是否为空，为空的话扩容，  不为空计算出key的hash值i，然后看table[i]是否为空，为空就直接插  入，不为空判断当前位置的key和table[i]是否相同，相同就覆盖，不相同  就查看table[i]是否是红黑树节点，如果是的话就用红黑树直接插入键值    对，如果不是开始遍历链表插入，如果遇到重复值就覆盖，否则直接插入，  如果链表长度大于8，转为红黑树结构，执行完成后看size是否大于阈值  threshold，大于就扩容，否则直接结束<br>get方法就是计算出要获取元素的hash值，去对应位置取即可。<br>扩容机制，hashmap的扩容中主要进行两部，第一步把数组长度变为原来的 两倍，第二部把旧数组的元素重新计算hash插入到新数组中，在jdk1.8时，不用重新计算hash，只用看看原来的hash值新增的一位是零还是1，如果是1这个元素在新数组中的位置，是原数组的位置加原数组长度，如果是零就插入到原数组中。扩容过程第二部一个非常重要的方法是transfer方法，采用头插法，把旧数组的元素插入到新数组中。<br>3.hashmap大小为什么是2的幂次方<br>在计算插入元素在hash桶数组的索引时第三步，为了使元素分布的更加均匀，用取模操作，但是传统取模操作效率低，然后优化成h&amp;(length-1)，设置成2幂次方，是因为2的幂次方-1后的值每一位上都是1，然后与第二步计算出的h值与的时候，最终的结果只和key的hashcode值本身有关，这样不会造成空间浪费并且分布均匀，如果不是2的幂次方<br>如果length不为2的幂，比如15。那么length-1的2进制就会变成1110。在h为随机数的情况下，和1110做&amp;操作。尾数永远为0。那么0001、1001、1101等尾数为1的位置就永远不可能被entry占用。这样会造成浪费，不随机等问题。  </p><h3 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h3><h4 id="1-单例及线程安全"><a href="#1-单例及线程安全" class="headerlink" title="1.单例及线程安全"></a>1.单例及线程安全</h4><p>spring依赖注入时，使用了双重判断加锁的单例模式，首先从缓存中获取bean实例，如果为null，对缓存map加锁，然后再从缓存中获取bean，如果继续为null，就创建一个bean。这样双重判断，能够避免在加锁的瞬间，有其他依赖注入引发bean实例的创建，从而造成重复创建的结果</p><h3 id="java静态方法不能调用非静态方法的原因"><a href="#java静态方法不能调用非静态方法的原因" class="headerlink" title="java静态方法不能调用非静态方法的原因"></a>java静态方法不能调用非静态方法的原因</h3><p>静态方法是属于类的，即静态方法是随着类的加载而加载的，在加载类时，程序就会为静态方法分配内存，而非静态方法是属于对象的，对象是在类加载之后创建的，也就是说静态方法先于对象存在，当你创建一个对象时，程序为其在堆中分配内存，一般是通过this指针来指向该对象。静态方法不依赖于对象的调用，它是通过‘类名.静态方法名’这样的方式来调用的。而对于非静态方法，在对象创建的时候程序才会为其分配内存，然后通过类的对象去访问非静态方法。因此在对象未存在时非静态方法也不存在，静态方法自然不能调用一个不存在的方法  </p><h3 id="JDK1-8新特性"><a href="#JDK1-8新特性" class="headerlink" title="JDK1.8新特性"></a>JDK1.8新特性</h3><ul><li>Lambda表达式</li><li>函数式接口</li><li>方法引用和构造器调用</li><li>Stream API</li><li>接口中的默认方法和静态方法</li><li>新时间日期API</li><li>default关键字<br>在jdk1.8中对hashMap等map集合的数据结构优化。hashMap数据结构的优化<br>原来的hashMap采用的数据结构是哈希表（数组+链表），hashMap默认大小是16，一个0-15索引的数组，如何往里面存储元素，首先调用元素的hashcode 方法，计算出哈希码值，经过哈希算法算成数组的索引值，如果对应的索引处没有元素，直接存放，如果有对象在，那么比较它们的equals方法比较内容<br>如果内容一样，后一个value会将前一个value的值覆盖，如果不一样，在1.7的时候，后加的放在前面，形成一个链表，形成了碰撞，在某些情况下如果链表 无限下去，那么效率极低，碰撞是避免不了的<br>加载因子：0.75，数组扩容，达到总容量的75%，就进行扩容，但是无法避免碰撞的情况发生<br>在1.8之后，在数组+链表+红黑树来实现hashmap，当碰撞的元素个数大于8时 &amp; 总容量大于64，会有<strong>红黑树</strong>的引入 除了添加之后，效率都比链表高，<strong>在jdk1.8之前是插入头部的，在jdk1.8中是插入尾部的。1.8之后链表新进元素加到末尾，</strong>在jdk1.6中，HashMap中有个内置Entry类，它  实现了Map.Entry接口；而在jdk1.8中，这个Entry类不见了，变成了  <strong>Node类</strong>，也实现了Map.Entry接口，与jdk1.6中的Entry是等价的。<br>红黑树插入：超过这个阈值后HashMap开始将列表升级成一个二叉树，，使用哈希值作为树的分支变量，如果两个哈希值不等，但指向同一个桶的话，较大的那个会插入到右子树里。如果哈希值相等，HashMap希望key值最好是实现了Comparable接口的，这样它可以按照顺序来进行插入。<br>ConcurrentHashMap (锁分段机制)，concurrentLevel,<strong>jdk1.8采用CAS算法(无锁算法，不再使用锁分段)</strong>，<strong>数组+链表中也引入了红黑树的使用</strong><br>— default关键字<br>通常都是认为接口里面是只能有抽象方法，不能有任何方法的实现的，那么在jdk1.8里面打破了这个规定，引入了新的关键字default，通过使用default修饰方法，可以让我们在接口里面定义具体的方法实现,如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface NewCharacter &#123;</span><br><span class="line">    </span><br><span class="line">    public void test1();</span><br><span class="line">    </span><br><span class="line">    public default void test2()&#123;</span><br><span class="line">        System.out.println(&quot;我是新特性1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>定义一个方法的作用是什么呢？为什么不在接口的实现类里面再去实现方法呢？<br>　　其实这么定义一个方法的主要意义是定义一个默认方法，也就是说这个接口的实现类实现了这个接口之后，不用管这个default修饰的方法，也可以直接调用，如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class NewCharacterImpl implements NewCharacter&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void test1() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        NewCharacter nca = new NewCharacterImpl();</span><br><span class="line">        nca.test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>default方法是所有的实现类都不需要去实现的就可以直接调用，那么比如说jdk的集合List里面增加了一个sort方法，那么如果定义为一个抽象方法，其所有的实现类如arrayList,LinkedList等都需要对其添加实现，那么现在用default定义一个默认的方法之后，其实现类可以直接使用这个方法了，这样不管是开发还是维护项目，都会大大简化代码量  </p><h3 id="继承和组合"><a href="#继承和组合" class="headerlink" title="继承和组合"></a>继承和组合</h3><p>借鉴这篇文章 ：<br><a href="https://blog.csdn.net/wrs120/article/details/88584705" target="_blank" rel="noopener">https://blog.csdn.net/wrs120/article/details/88584705</a></p><h4 id="继承优点："><a href="#继承优点：" class="headerlink" title="继承优点："></a>继承优点：</h4><ul><li>代码复用</li><li>子类可重写父类方法</li><li>子类在父类的继承上可根据自己的业务需求扩展</li><li>创建子类对象时，无需创建父类对象，子类自动继承父类的的成员变量和方法，如果权限允许，子类可直接访问<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4></li><li>不支持动态继承，在编译阶段就确定了子类的父类</li><li>破坏封装性</li><li>封装性指出每个类都应该封装它内容信息和实现细节，而只暴露必要的方法给其他类使用。但在继承关系中，子类可以直接访问父类的成员变量和方法，如下例子中父类Fruit中有成员变量weight。Apple继承了Fruit之后,Apple可直接操作Fruit类的成员变量，因此破坏了封装性!</li><li>紧耦合<br>当父类的实现做了修改时，父类也不得不修改（比如修改了父类某个接口名，子类也必须作相应修改）；子类必须依赖父类存在</li></ul><h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul><li>支持动态扩展，可在运行时根据具体对象选择不同类型的组合对象(扩展性比继承好)</li><li>不破坏封装性</li><li>松耦合<h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5></li><li>整体类不能自动获取局部类的接口(整体类可      以看成是上面的bird，如果想在bird里使用Animal的方法，必须写代码来调用，但是继承，bird自动就拥有了animal的方法)</li><li>没有实现多态</li></ul><h4 id="组合举例"><a href="#组合举例" class="headerlink" title="组合举例"></a>组合举例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Animal &#123;</span><br><span class="line">    private void beat()&#123;</span><br><span class="line">        System.out.println(&quot;心脏跳动...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void breath()&#123;</span><br><span class="line">        beat();</span><br><span class="line">        System.out.println(&quot;呼吸中...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Bird &#123;</span><br><span class="line">    //将Animal作为Bird的成员变量</span><br><span class="line">    private Animal a;</span><br><span class="line">    public Bird(Animal a)&#123;</span><br><span class="line">        this.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    public void breath()&#123;</span><br><span class="line">        a.breath();</span><br><span class="line">    &#125;</span><br><span class="line">    public void fly()&#123;</span><br><span class="line">        System.out.println(&quot;我在飞..&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Animal animal = new Animal();</span><br><span class="line">        Bird b = new Bird(animal);</span><br><span class="line">        b.breath();</span><br><span class="line">        b.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择?"></a>如何选择?</h4><ul><li>想实现复用，并且复用部分可能改变，用继承；复用不会改变，用组合</li><li>当两个类之间明显存在整体与部分的关系时，用组合关系</li></ul><h3 id="进程间的通讯方式"><a href="#进程间的通讯方式" class="headerlink" title="进程间的通讯方式"></a>进程间的通讯方式</h3><h4 id="liunx六大进程间通信方式"><a href="#liunx六大进程间通信方式" class="headerlink" title="liunx六大进程间通信方式"></a>liunx六大进程间通信方式</h4><h5 id="管道，消息队列，共享内存，信号量，socket，信号，文件锁"><a href="#管道，消息队列，共享内存，信号量，socket，信号，文件锁" class="headerlink" title="管道，消息队列，共享内存，信号量，socket，信号，文件锁"></a>管道，消息队列，共享内存，信号量，socket，信号，文件锁</h5><ul><li><p>1，管道</p><pre><code>1，匿名管道：           概念：在内核中申请一块固定大小的缓冲区，程序拥有写入和读取的权利，一般使用fork函数实现父子进程的通信。2，命名管道：             概念：在内核中申请一块固定大小的缓冲区，程序拥有写入和读取的权利，没有血缘关系的进程也可以进程间通信。3，特点：          1，面向字节流，          2，生命周期随内核          3，自带同步互斥机制。          4，半双工，单向通信，两个管道实现双向通信。  </code></pre></li><li>2，消息队列<br> 1，概念：在内核中创建一队列，队列中每个元素是一个数据报，不同的进程可以通过句柄去访问这个队列。<pre><code>           消息队列提供了⼀个从⼀个进程向另外⼀ 个进程发送⼀块数据的⽅法。            每个数据块都被认为是有⼀个类型，接收者进程接收的数据块可以有不同的类型值                                                                 消息队列也有管道⼀样的不⾜，就是每个消息的最⼤⻓度是有上限的（MSGMAX），            每个消息队 列的总的字节数是有上限的（MSGMNB），系统上消息队列的总数也有⼀个上限（MSGMNI）  </code></pre>  2，特点：<pre><code>        1， 消息队列可以认为是一个全局的一个链表，链表节点钟存放着数据报的类型和内容，有消息队列的标识符进行标记。        2，消息队列允许一个或多个进程写入或者读取消息。        3，消息队列的生命周期随内核。        4，消息队列可实现双向通信。</code></pre></li><li><p>3，信号量     </p><pre><code>  1，概念                在内核中创建一个信号量集合（本质是个数组），数组的元素（信号量）都是1，使用P操作进行-1，使用V操作+1，                （1） P(sv)：如果sv的值⼤大于零，就给它减1；如果它的值为零，就挂起该进程的执⾏ 。                （2） V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运⾏，如果没有进程因等待sv⽽挂起，就给它加1。                     PV操作用于同一进程，实现互斥。                    PV操作用于不同进程，实现同步。   2，功能：               对临界资源进行保护。       </code></pre></li><li>4，共享内存      <pre><code> 1，概念：            将同一块物理内存一块映射到不同的进程的虚拟地址空间中，实现不同进程间对同一资源的共享。            共享内存可以说是最有用的进程间通信方式，也是最快的IPC形式。  2，特点：           1，不用从用户态到内核态的频繁切换和拷贝数据，直接从内存中读取就可以。           2，共享内存是临界资源，所以需要操作时必须要保证原子性。使用信号量或者互斥锁都可以。           3，生命周期随内核。     </code></pre></li><li>5，总结<pre><code>  所有的以上的方式都是生命周期随内核，不手动释就不会消失。</code></pre></li></ul><h3 id="为什么java不提供指针访问内存就会内存更安全"><a href="#为什么java不提供指针访问内存就会内存更安全" class="headerlink" title="为什么java不提供指针访问内存就会内存更安全"></a>为什么java不提供指针访问内存就会内存更安全</h3><p><a href="https://bbs.csdn.net/topics/50223289" target="_blank" rel="noopener">https://bbs.csdn.net/topics/50223289</a><br>java的设计思想就是“安全第一”，将大部分工作转移到堆上，严格限制指针的使用（甚至连指针这个名字都不用）。但是java中还是有指针的，当我们创建一个对象实例时，也就同时声明了一个指向该实例的堆存储空间入口地址的指针，这个指针也称为“引用”。引用可以指向其他相关类型的实例存储空间，但是<strong>只能指向这些存储空间的入口地址</strong>，<strong>不能任意指向其中的存储区域</strong>；再配合GC，<strong>提供了很好的安全性。Java实际上就是将管理内存的指针操作都封装在jvm中</strong>，让程序员能够更多地关注于方案的设计和优化。  </p><h3 id="构造器-Constructor-是否可被-override"><a href="#构造器-Constructor-是否可被-override" class="headerlink" title="构造器 Constructor 是否可被 override?"></a>构造器 Constructor 是否可被 override?</h3><p>在讲继承的时候我们就知道父类的私有属性和<strong>构造方法并不能被继承</strong>，所以 Constructor 也就<strong>不能被 override（重写）,但是可以 overload（重载）</strong>,所以你可以看到一个类中有多个构造函数的情况。  </p><h3 id="10-重载和重写的区别"><a href="#10-重载和重写的区别" class="headerlink" title="10. 重载和重写的区别"></a>10. 重载和重写的区别</h3><ul><li>重载： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 　　</li><li>重写： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。   </li></ul><h3 id="关于继承如下-3-点请记住："><a href="#关于继承如下-3-点请记住：" class="headerlink" title="关于继承如下 3 点请记住："></a>关于继承如下 3 点请记住：</h3><p>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。<br>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。<br>子类可以用自己的方式实现父类的方法。（以后介绍）。    </p><h3 id="18-成员变量与局部变量的区别有那些？"><a href="#18-成员变量与局部变量的区别有那些？" class="headerlink" title="18. 成员变量与局部变量的区别有那些？"></a>18. 成员变量与局部变量的区别有那些？</h3><p>从语法形式上看:成员变量是属于类的，而局部变量是在方法中定义的变量  或是方法的参数；成员变量可以被 public,private,static 等修饰符   所修饰，而<strong>局部变量不能被访问控制修饰符及 static 所修饰</strong>；但是，成员变量和局部变量都能被 final 所修饰。<br>从变量在内存中的存储方式来看:如果成员变量是使用static修饰的，那么  这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。<br>从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。<br>成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而<strong>局部变量则不会自动赋值</strong>。    </p><h3 id="在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是"><a href="#在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是" class="headerlink" title="在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?"></a>在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?</h3><p>帮助子类做初始化工作    </p><h3 id="总结一下Java中方法参数的使用情况："><a href="#总结一下Java中方法参数的使用情况：" class="headerlink" title="总结一下Java中方法参数的使用情况："></a>总结一下Java中方法参数的使用情况：</h3><ul><li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li><li>一个方法可以改变一个对象参数的状态。</li><li>一个方法不能让对象参数引用一个新的对象。  (对象引用做参数实际上是对引用做了一份拷贝，所以可以相应改变对象的状态，但是却没法让对象参数引用一个新的对象)  <h3 id="Java异常类层次结构图"><a href="#Java异常类层次结构图" class="headerlink" title="Java异常类层次结构图"></a>Java异常类层次结构图</h3><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-2/Exception.png" alt="Java异常类层次结构图"> </li></ul><h4 id="异常处理总结"><a href="#异常处理总结" class="headerlink" title="异常处理总结"></a>异常处理总结</h4><ul><li>try 块：用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则<strong>必须跟一个finally块</strong>。</li><li>catch 块：用于处理try捕获到的异常。</li><li>finally 块：无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中<strong>遇到return语句时，finally语句块将在方法返回之前被执行</strong>。  <h3 id="在以下4种特殊情况下，finally块不会被执行："><a href="#在以下4种特殊情况下，finally块不会被执行：" class="headerlink" title="在以下4种特殊情况下，finally块不会被执行："></a>在以下4种特殊情况下，finally块不会被执行：</h3></li><li>在finally语句块第一行发生了异常。 因为在其他行，finally块还是会得到执行</li><li>在前面的代码中用了System.exit(int)已退出程序。 exit是带参函数 ；若该语句在异常语句之后，finally会执行</li><li>程序所在的线程死亡。</li><li>关闭CPU。  </li></ul><h3 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h3><p>static 关键字主要有以下四种使用场景：  </p><ul><li>修饰成员变量和成员方法: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：类名.静态变量名 类名.静态方法名()</li><li>静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.</li><li>静态内部类（static修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。</li><li>静态导包(用来导入类中的静态资源，1.5之后的): 格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。    </li></ul><h3 id="所有整形包装类对象值的比较必须使用equals方法。"><a href="#所有整形包装类对象值的比较必须使用equals方法。" class="headerlink" title="所有整形包装类对象值的比较必须使用equals方法。"></a>所有整形包装类对象值的比较必须使用equals方法。</h3><p>先看下面这个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer x = 3;  </span><br><span class="line">Integer y = 3;</span><br><span class="line">System.out.println(x == y);// true</span><br><span class="line">Integer a = new Integer(3);</span><br><span class="line">Integer b = new Integer(3);</span><br><span class="line">System.out.println(a == b);//false</span><br><span class="line">System.out.println(a.equals(b));//false</span><br></pre></td></tr></table></figure></p><p>当使用自动装箱方式创建一个Integer对象时，当数值在-128 ~127时，会将创建的Integer对象缓存起来，当下次再出现该数值时，直接从缓存中取出对应的Integer对象。所以上述代码中，x和y引用的是相同的Integer对象。  </p><h3 id="get和post请求的区别"><a href="#get和post请求的区别" class="headerlink" title="get和post请求的区别"></a>get和post请求的区别</h3><p>网上也有文章说：get和post请求实际上是没有区别，大家可以自行查询相关文章（参考文章：<a href="https://www.cnblogs.com/logsharing/p/8448446.html，知乎对应的问题链接：get和post区别？）！我下面给出的只是一种常见的答案。" target="_blank" rel="noopener">https://www.cnblogs.com/logsharing/p/8448446.html，知乎对应的问题链接：get和post区别？）！我下面给出的只是一种常见的答案。</a></p><ul><li><p>①get请求用来从服务器上获得资源，而post是用来向服务器提交数据；</p></li><li><p>②get将表单中数据按照name=value的形式，添加到action 所指向的URL 后面，并且两者使用”?”连接，而各个变量之间使用”&amp;”连接；post是将表单中的数据放在HTTP协议的请求头或消息体中，传递到action所指向URL；</p></li><li><p>③get传输的数据要受到URL长度限制（最大长度是 2048 个字符）；而post可以传输大量的数据，上传文件通常要使用post方式；</p></li><li><p>④使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post；</p></li><li><p>⑤get使用MIME类型application/x-www-form-urlencoded的URL编码（也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是”%20”。</p></li></ul><p>补充：GET方式提交表单的典型应用是搜索引擎。GET方式就是被设计为查询用的。</p><h4 id="对于GET方式的请求，浏览器会把http-header和data一并发送出去，服务器响应200（返回数据）；"><a href="#对于GET方式的请求，浏览器会把http-header和data一并发送出去，服务器响应200（返回数据）；" class="headerlink" title="对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；"></a>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</h4><h4 id="而对于POST，浏览器先发送header，服务器响应100-continue，浏览器再发送data，服务器响应200-ok（返回数据）。"><a href="#而对于POST，浏览器先发送header，服务器响应100-continue，浏览器再发送data，服务器响应200-ok（返回数据）。" class="headerlink" title="而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。"></a>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</h4><ul><li>也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。<h3 id="转发-Forward-和重定向-Redirect-的区别"><a href="#转发-Forward-和重定向-Redirect-的区别" class="headerlink" title="转发(Forward)和重定向(Redirect)的区别"></a>转发(Forward)和重定向(Redirect)的区别</h3></li><li><p>转发是服务器行为，重定向是客户端行为。</p></li><li><p>转发（Forward） 通过RequestDispatcher对象的forward（HttpServletRequest request,HttpServletResponse response）方法实现的。RequestDispatcher可以通过HttpServletRequest 的getRequestDispatcher()方法获得。例如下面的代码就是跳转到login_success.jsp页面。</p><p>   request.getRequestDispatcher(“login_success.jsp”).forward(request, response);</p></li><li><p>重定向（Redirect） 是利用服务器返回的状态码来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过 HttpServletResponse 的 setStatus(int status) 方法设置状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源。</p></li><li><p>从地址栏显示来说<br>forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址. redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.</p></li><li><p>从数据共享来说<br>forward:转发页面和转发到的页面可以共享request里面的数据. redirect:不能共享数据.</p></li><li><p>从运用地方来说<br>forward:一般用于用户登陆的时候,根据角色转发到相应的模块. redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等</p></li><li><p>从效率来说<br>forward:高. redirect:低.</p></li></ul><h3 id="关于java的对象和集合长度注意"><a href="#关于java的对象和集合长度注意" class="headerlink" title="关于java的对象和集合长度注意"></a>关于java的对象和集合长度注意</h3><ul><li>java 中的 length 属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li><li>java 中的 length() 方法是针对字符串说的,如果想看这个字符串的长度则用到 length() 这个方法.</li><li>java 中的 size() 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li></ul><h3 id="LinkedHashMap-结构图（hashmap结构基础上增加了双向链表）"><a href="#LinkedHashMap-结构图（hashmap结构基础上增加了双向链表）" class="headerlink" title="LinkedHashMap 结构图（hashmap结构基础上增加了双向链表）"></a>LinkedHashMap 结构图（hashmap结构基础上增加了双向链表）</h3><p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15166338955699.jpg" alt="LinkedHashMap">    </p><h3 id="4-1-为什么要用线程池？"><a href="#4-1-为什么要用线程池？" class="headerlink" title="4.1. 为什么要用线程池？"></a>4.1. 为什么要用线程池？</h3><p>线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。  </p><ul><li><p>降低资源消耗。 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。  </p></li><li><p>提高响应速度。 当任务到达时，任务可以不需要的等到线程创建就能立即执行。</p></li><li>提高线程的可管理性。 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。  </li></ul><h3 id="java的自动拆装箱"><a href="#java的自动拆装箱" class="headerlink" title="java的自动拆装箱"></a>java的自动拆装箱</h3><p><a href="https://www.cnblogs.com/kitor/p/10469276.html" target="_blank" rel="noopener">转载：</a> </p><h4 id="案例引入："><a href="#案例引入：" class="headerlink" title="案例引入："></a>案例引入：</h4><pre><code>public static void main(String[] args) {Integer i = 10;Integer j = 10;System.out.println(i == j);Integer a = 128;Integer b = 128;System.out.println(a == b);int k = 10;System.out.println(k == i);int kk = 128;System.out.println(kk == a);Integer m = new Integer(10);Integer n = new Integer(10);System.out.println(m == n);}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">执行结果：</span><br></pre></td></tr></table></figure><pre><code>    true    false    true    true    false</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure><p>Java中的语法糖也是新增了一些语法，使得程序员使用更加方便。但是计算机底层还是使用基本语法来实现的。下面我们讨论几个经常使用到的语法糖，可变参数、自动装箱/拆箱、增强for循环。</p><p>我们以Integer类为例，在我们用如下代码编写程序后，当使用Javac.exe工具操作之后，编译器会把我们的这个程序重写按照DRY（Don’t repeat yourself）原则进行编译  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer num1 = 123;//将一个基本数据类型赋给Integer对象</span><br><span class="line">        int num2 = num1;//将一个Integer对象赋给整形变量</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">对以上代码编译后的Test.class反编译结果如下</span><br></pre></td></tr></table></figure><pre><code>public class Test{      public static void main(String[] args) {        Integer num1 = Integer.valueOf(123);//装箱操作           int num2 = num1.intValue();//拆箱操作      }}</code></pre><pre><code>- 结果分析了解了上面代码的转换过程，我们从反编译的结果得知：再Java语言中永远遵守不同类型之间不可以进行赋值的规则。置于我们在代码中的编写形式有时只是进行了简写，而最后的执行还要依赖于编译器的解析结果。- 实现过程上方就是基本数据类型的自动拆/装箱，他们的装箱遵循以下规则自动装箱规范要求 byte&lt;= 127、char&lt;=127、-128&lt;=short &lt;=127、-128&lt;=int &lt;=127都被包装到固定的对象中（缓存）。也就是说在装箱过程中执行valueOf(参数)方法后，如果满足以上条件就会被封装成Integer对象中。valueOf函数如下: ![](https://img2018.cnblogs.com/blog/1500954/201903/1500954-20190304115238909-1677329599.png)  从函数可以看出，当在-128到127范围内，会生成同一个对象，在范围之外，会执行new Integer（）；我们都知道在Java语言中，new一个对象是存储在堆里的，我们通过栈中的引用来使用这些对象；所以，对象本身来说是比较消耗资源的。  - 总结   包装类的应用1、Java中的集合类只能接收对象类型，而Java通过包装类实现了把基本数据类型放入集合操作的目的。并且在放入集合的时候这种封装时自动完成的。2、包装类与基本数据类型进行比较运算，是先将包装类进行拆箱成基本数据类型，然后进行比较的。3、两个包装类型之间的运算，会被自动拆箱成基本类型进行。4、三目运算符flag ? i : j;片段中，三目运算符的语法规范：当第二，第三位操作数分别为基本类型和对象时，其中的对象就会拆箱为基本类型进行操作。如果这个时候i的值为null，那么久会发生NPE。（自动拆箱导致空指针异常）5、函数参数与返回值6、Integer中的缓存机制有关。在Java 5中，在Integer的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用。适用于整数值区间-128 至 +127。只适用于自动装箱。使用**构造函数创建对象不适用**。当需要进行自动装箱时，如果数字在-128至127之间时，会直接使用缓存中的对象，而不是重新创建一个对象。另外javadoc详细的说明了缓存支持-128到127之间的自动装箱过程。最大值127可以通过-XX:AutoBoxCacheMax=size修改。实际上这个功能在Java 5中引入的时候,范围是固定的-128 至 +127。后来在Java 6中，可以通过java.lang.Integer.IntegerCache.high设置最大值。    - 注意事项  包装类的使用简化了代码，方便了编程者对数据的操作，实现了面向对象思想，但是也引入了一些麻烦，我们要尽量避免，以防对以后的编程中出现负担。1、包装对象的数值比较，不能简单的使用==，虽然-128到127之间的数字可以，但是这个范围之外还是需要使用equals比较。2、如果一个for循环中有大量拆装箱操作，会浪费很多资源。3、有些场景会进行自动拆装箱，同时也说过，由于自动拆箱，如果包装类对象为null，那么自动拆箱时就有可能抛出NPE。### hashmap  - hashmap是一个key-value键值对的数据结构，从结构上来讲在jdk1.8之前是用数组加链表的方式实现，jdk1.8加了红黑树，hashmap数组的默认初始长度是16，hashmap数组只允许一个key为null，允许多个value为null- **hashmap的内部实现**，hashmap是使用数组+链表+红黑树的形式实现的，其中数组是一个一个Node[]数组，我们叫他hash桶数组，它上面存放的是key-value键值对的节点。HashMap是用hash表来存储的，在hashmap里为解决hash冲突，使用链地址法，简单来说就是数组加链表的形式来解决，当数据被hash后，得到数组下标，把数据放在对应下表的链表中。- 然后再说一下hashmap的方法实现- **put方法**，put方法的第一步，就是计算出要put元素在hash桶数组中的索引位置，得到索引位置需要三步，去put元素key的hashcode值，高位运算，取模运算，高位运算就是用第一步得到的值h，用h的高16位和低16位进行异或操作，第三步为了使hash桶数组元素分布更均匀，采用取模运算，取模运算就是用第二步得到的值和hash桶数组长度-1的值取与。这样得到的结果和传统取模运算结果一致，而且效率比取模运算高jdk1.8中put方法的具体步骤，首先判断key是否为null，若为null，则直接调用putForNullKey方法。先判断hashmap是否为空，为空的话扩容，不为空计算出key的hash值i，然后看table[i]是否为空，为空就直接插入，不为空判断当前位置的key和table[i]是否相同，相同就覆盖，不相同就查看table[i]是否是红黑树节点，如果是的话就用红黑树直接插入键值对，如果不是开始遍历链表插入，如果遇到重复值就覆盖，否则直接插入，如果链表长度大于8，转为红黑树结构，执行完成后看size是否大于阈值threshold，大于就扩容，否则直接结束          public V put(K key, V value) {        //当key为null，调用putForNullKey方法，保存null与table第一个位置中，这是HashMap允许为null的原因        if (key == null)            return putForNullKey(value);        //计算key的hash值        int hash = hash(key.hashCode());                  ------(1)        //计算key hash值在table数组中的位置        int i = indexFor(hash, table.length);             ------(2)        //从i出开始迭代e,找到key保存的位置        for (Entry&lt;K, V&gt; e = table[i]; e != null; e = e.next) {            Object k;            //判断该条链上是否有hash值相同的(key相同)            //若存在相同，则直接覆盖value，返回旧value            if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {                V oldValue = e.value;    //旧值=新值                e.value = value;                e.recordAccess(this);                return oldValue;     //返回旧值            }        }        //修改次数增加1        modCount++;        //将key、value添加至i位置处        addEntry(hash, key, value, i);        return null;    }        //当key为null，调用putForNullKey方法，保存null与table第一个位置中，这是HashMap允许为null的原因        if (key == null)            return putForNullKey(value);  - get方法就是计算出要获取元素的hash值，去对应位置取即可。- **扩容机制**，hashmap的扩容中主要进行两部， - 第一步把数组长度变为原来的两倍   - 第二部把旧数组的元素重新计算hash插入到新数组中，在jdk1.8时，不用重新计算hash，只用看看原来的hash值新增的一位是零还是1，如果是1这个元素在新数组中的位置，是原数组的位置加原数组长度，如果是零就插入到原数组中(检测元素的hash值与原数组长度作与操作的结果是否为0：为0，那么下标还是原来的下标；为1，那么下标等于原来下标加上旧数组长度。)，并且把transfer方法放在了resize()里边实现。扩容过程第二部一个非常重要的方法是transfer方法，采用头插法，把旧数组的元素插入到新数组中。  数组长度：2，key：3 0 0 0 1 0 0 1 1 结果为 0 0 0 1 = 1 所以数组下标为1；扩容后，数组长度：4，key：3 0 0 1 1 0 0 1 1 结果为 0 0 1 1 = 3 = 原来的index + oldCap = 1 + 2确定元素在新数组的下标时，我们只需要检测元素的hash值与oldCap作与操作的结果是否为0：为0，那么下标还是原来的下标；为1，那么下标等于原来下标加上旧数组长度。  - hashmap大小为什么是2的幂次方在计算插入元素在hash桶数组的索引时第三步，为了使元素分布的更加均匀，用取模操作，但是传统取模操作效率低，然后优化成h&amp;(length-1)，设置成2幂次方，是因为2的幂次方-1后的值每一位上都是1，然后与第二步计算出的h值与的时候，最终的结果只和key的hashcode值本身有关，这样不会造成空间浪费并且分布均匀，如果不是2的幂次方如果length不为2的幂，比如15。那么length-1的2进制就会变成1110。在h为随机数的情况下，和1110做&amp;操作。尾数永远为0。那么0001、1001、1101等尾数为1的位置就永远不可能被entry占用。这样会造成浪费，不随机等问题。    #### 如果事先能估算出容器所要存储的元素数量，最好在初始化时修改默认容量capacity，以防止频繁的resize操作影响性能。  ### yield  和sleep区别yield()没有参数    sleep 方法使当前运行中的线程睡眠一段时间，进入不可以运行状态，这段时间的长短是由程序设定的，yield方法使当前线程让出CPU占有权，但让出的时间是不可设定的。    yield()也不会释放锁标志。    实际上，yield()方法对应了如下操作；先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把CPU的占有权交给次线程，否则继续运行原来的线程，所以yield()方法称为**“退让”**，它把运行机会让给了同等级的其他线程。    sleep 方法允许较低优先级的线程获得运行机会，但yield（）方法执行时，当前线程仍处在可运行状态，所以不可能让出较低优先级的线程此时获取CPU占有权。在一个运行系统中，如果较高优先级的线程没有调用sleep方法，也没有受到I/O阻塞，那么较低优先级线程只能等待所有较高优先级的线程运行结束，方可有机会运行。    yield()只是使当前线程重新回到可执行状态，所有执行yield()的线程有可能在进入到可执行状态后马上又被执行，所以yield()方法只能使同优先级的线程有执行的机会。### 面向对象基本原则  - 1. 单一职责原则（Single Responsibility Principle）每一个类应该专注于做一件事情。- 2. 里氏替换原则（Liskov Substitution Principle）超类存在的地方，子类是可以替换的。- 3. 依赖倒置原则（Dependence Inversion Principle）实现尽量依赖抽象，不依赖具体实现。- 4. 接口隔离原则（Interface Segregation Principle）应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。- 5. 迪米特法则（Law Of Demeter）又叫最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用。- 6. 开闭原则（Open Close Principle）面向扩展开放，面向修改关闭。- 7. 组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）尽量使用合成/聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象。   #### 细则- 单一职责原则（Single Responsibility Principle）因为：可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；提高类的可读性，提高系统的可维护性；变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。所以：从大局上看Android中的Paint和Canvas等类都遵守单一职责原则，Paint和Canvas各司其职。- 里氏替换原则（Liskov Substitution Principle）因为：里氏替换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。里氏替换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。所以：使用里氏替换原则时需要注意，子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。从大局看Java的多态就属于这个原则。- 依赖倒置原则（Dependence Inversion Principle）因为：具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类；而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口；这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖。所以：采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，减少并行开发引起的风险，提高代码的可读性和可维护性。从大局看Java的多态就属于这个原则。- 接口隔离原则（Interface Segregation Principle）因为：提供尽可能小的单独接口，而不要提供大的总接口。暴露行为让后面的实现类知道的越少越好。譬如类ProgramMonkey通过接口CodeInterface依赖类CodeC，类ProgramMaster通过接口CodeInterface依赖类CodeAndroid，如果接口CodeInterface对于类ProgramMonkey和类CodeC来说不是最小接口，则类CodeC和类CodeAndroid必须去实现他们不需要的方法。将臃肿的接口CodeInterface拆分为独立的几个接口，类ProgramMonkey和类ProgramMaster分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。所以：建立单一接口，不要建立庞大的接口，尽量细化接口，接口中的方法尽量少。也就是要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的约定，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。从大局来说Java的接口可以实现多继承就是接口隔离原则的基础保障。- 迪米特法则（Law Of Demeter）因为：类与类之间的关系越密切，耦合度也就越来越大，只有尽量降低类与类之间的耦合才符合设计模式；对于被依赖的类来说，无论逻辑多复杂都要尽量封装在类的内部；每个对象都会与其他对象有耦合关系，我们称出现成员变量、方法参数、方法返回值中的类为直接的耦合依赖，而出现在局部变量中的类则不是直接耦合依赖，也就是说，不是直接耦合依赖的类最好不要作为局部变量的形式出现在类的内部。所以：一个对象对另一个对象知道的越少越好，即一个软件实体应当尽可能少的与其他实体发生相互作用，在一个类里能少用多少其他类就少用多少，尤其是局部变量的依赖类，能省略尽量省略。同时如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一方法的话，可以通过第三者转发这个调用。从大局来说Android App开发中的多Fragment与依赖的Activity间交互通信遵守了这一法则。- 开闭原则（Open Close Principle）因为：开放封闭原则主要体现在对扩展开放、对修改封闭，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。软件需求总是变化的，世界上没有一个软件的是不变的，因此对软件设计人员来说，必须在不需要对原有系统进行修改的情况下，实现灵活的系统扩展。所以：可以通过Template Method模式和Strategy模式进行重构，实现对修改封闭，对扩展开放的设计思路。 封装变化，是实现开放封闭原则的重要手段，对于经常发生变化的状态，一般将其封装为一个抽象，拒绝滥用抽象，只将经常变化的部分进行抽象。- 组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）因为：其实整个设计模式就是在讲如何类与类之间的组合/聚合。在一个新的对象里面通过关联关系（包括组合关系和聚合关系）使用一些已有的对象，使之成为新对象的一部分，新对象通过委派调用已有对象的方法达到复用其已有功能的目的。也就是，要尽量使用类的合成复用，尽量不要使用继承。如果为了复用，便使用继承的方式将两个不相干的类联系在一起，违反里氏代换原则，哪是生搬硬套，忽略了继承了缺点。继承复用破坏数据封装性，将基类的实现细节全部暴露给了派生类，基类的内部细节常常对派生类是透明的，白箱复用；虽然简单，但不安全，不能在程序的运行过程中随便改变；基类的实现发生了改变，派生类的实现也不得不改变；从基类继承而来的派生类是静态的，不可能在运行时间内发生改变，因此没有足够的灵活性。所以：组合/聚合复用原则可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合/聚合来实现复用；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。  ### 如何正确使用线程池  https://www.cnblogs.com/CarpenterLee/p/9558026.html  避免使用无界队列不要使用Executors.newXXXThreadPool()快捷方法创建线程池，因为这种方式会使用无界的任务队列，为避免OOM，我们应该使用ThreadPoolExecutor的构造方法手动指定队列的最大长度：    ExecutorService executorService = new ThreadPoolExecutor(2, 2,                     0, TimeUnit.SECONDS,                     new ArrayBlockingQueue&lt;&gt;(512), // 使用有界队列，避免OOM                    new ThreadPoolExecutor.DiscardPolicy());   Executors中创建线程池的快捷方法，实际上是调用了ThreadPoolExecutor的构造方法（定时任务使用的是ScheduledThreadPoolExecutor），该类构造方法参数列表如下：    // Java线程池的完整构造函数    public ThreadPoolExecutor(      int corePoolSize, // 线程池长期维持的线程数，即使线程处于Idle状态，也不会回收。      int maximumPoolSize, // 线程数的上限      long keepAliveTime, TimeUnit unit, // 超过corePoolSize的线程的idle时长，                                         // 超过这个时间，多余的线程会被回收。      BlockingQueue&lt;Runnable&gt; workQueue, // 任务的排队队列      ThreadFactory threadFactory, // 新线程的产生方式      RejectedExecutionHandler handler) // 拒绝策略  ### 关于null  [java中的null类型---有关null的9件事](https://blog.csdn.net/qq_25077777/article/details/80174763) 因为null类型没有名字，所以不可能声明为null类型的变量或者转换为null类型。            null引用是null类型表达式唯一可能的值。            null引用可以转换为任意引用类型。            实际上，程序员可以忽略null类型，可以认为null仅仅是一个可以称为任何引用类型的特殊符号。            一个null类型(null(空)引用是这种类型的唯一的一个值)，可以赋值给任意类型，将返回一个该类型对象的空引用(其实还是null)。#### 关于null的9件事  - 1）首先，null是java中的关键字，像public、static、final。它是大小写敏感的  -  2）     就像每种原始类型都有默认值一样，int默认值为0，boolean的默认值为false，null是任何引用类型的默认值，不严格的说是所有object类型的默认值。就像你创建了一个布尔类型的变量，它将false作为自己的默认值，java中的任何引用变量都将null作为默认值。这对所有变量都是适用的，如成员变量、局部变量、实例变量、静态变量(但当你使用一个没有初始化的局部变量，编译器会警告你)。![](https://img-blog.csdn.net/20180503184702562?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MDc3Nzc3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)  这对静态和非静态的object来说都是正确的。就像你在这里看到的这样，myObj定义为静态引用，所以可以在主方法里直接使用它。**注意：主方法是静态方法，不可使用非静态变量。** -  3）     要澄清一些误解，null既不是对象也不是一种类型，它仅是一种特殊的值，你可以将其赋予任何引用类型，你也可以将null转化成任何类型  -  4）    null可以赋值给引用变量，**不能将null赋值给基本类型变量，如int、double、float、boolean。 ** ![](https://img-blog.csdn.net/20180503185646347?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MDc3Nzc3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)  ![](https://img-blog.csdn.net/20180503185757305?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MDc3Nzc3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)  -   5）    任何含有null值的包装类在java拆箱生成基本数据类型时候都会抛出一个空指针异常。  -  6）     如果使用了带有null值的引用类型的变量，instanceof操作会返回false  ![](https://img-blog.csdn.net/20180503191057973?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MDc3Nzc3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)  - 7）    可以使用静态方法来使用一个值为null的引用类型变量。因为静态方法使用静态类型绑定，不会抛空指针异常  ![](https://img-blog.csdn.net/20180503191921843?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MDc3Nzc3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)  -  8）        可以将null传递给方法使用，这时方法可以接收任何引用类型，如 public void print(Object obj) 可以这样调用print(null).编译可以通过，但结果就取决去你的方法了。这个例子中的print方法，不会抛出空指针异常，只是退出，业务逻辑允许的话，推荐使用null安全的方法。  #### 还有一个问题，当用System.out.println()打印一个对象时，不是要调用对象的toString()方法吗？但是打印时并没有报错，这什么原因呢？查看println()源码：          public void println(Object x) {        String s = String.valueOf(x);        synchronized (this) {            print(s);            newLine();        }    }  方法首先把对象转化为字符串，查看valueOf()源码：     public static String valueOf(Object obj) {    return (obj == null) ? &quot;null&quot; : obj.toString();    }可以看到，把对象转化为字符串的过程是，先把对象和null比较，如果为真，直接返回“null”,如果为假，也就是说对象不是null，再调用toString方法。这就是打印null对象不报错的原因。  我们顺便看看print()的源码：          public void print(String s) {    if (s == null) {        s = &quot;null&quot;;    }    write(s);    }  可见，print()只是用来打印字符串对象的，而且针对null字符串也有特别处理。  -  9)    可以使用== 或者 != 操作来比较null值，但是不能使用其他算法或者逻辑操作，如大于、小于。与SQL不同，java中的null==null会返回true；  ### 为什么HashMap非线程安全  [为什么HashMap非线程安全](https://blog.csdn.net/wufaliang003/article/details/80219296)  rehash方法会在链表中造成循环引用，形成链表环  ### [雪崩效应](https://www.cnblogs.com/toov5/p/9895929.html)    ### [volatile,sychronized底层原理](https://www.cnblogs.com/yuxiang1/p/11310575.html)  https://www.cnblogs.com/yuxiang1/p/11305546.html### [Valotile底层](https://www.cnblogs.com/xyang/p/8656034.html)  ### [reentrentlock底层原理](https://blog.csdn.net/BlackPlus28/article/details/82764772)  [ReentrantLock实现原理](https://www.cnblogs.com/zhangfengshi/p/9203191.html)  ### [联合索引最左前缀](https://www.cnblogs.com/wezheng/p/8399305.html)  ### [select，poll，epoll优缺点及比较](https://www.cnblogs.com/llguanli/p/8721103.html)  - epoll把用户注冊的文件描写叙述符和事件放到内核当中的事件表中。提供了一个独立的系统调用epoll_ctl来管理用户的事件，并且epoll**採用回调的方式**。一旦有注冊的**文件描写叙述符就绪**，讲**触发回调函数**，该回调函数将**就绪的文件描写叙述符和事件**复制到**用户空间events**所管理的内存。这样应用程序索引就绪文件的时间复杂度达到O(1)。    ![](https://img-blog.csdn.net/20160422143642896)  ### [select，poll，epoll优缺点及比较2](https://blog.csdn.net/mmbbz/article/details/70303951)   ### [Websocket原理](https://blog.csdn.net/yinqingwang/article/details/52565133)  ### Linux命令统计实现找出日志文件中监听请求数前十多的数?  https://www.cnblogs.com/zhaijing/p/9767285.html  https://blog.csdn.net/ahjxhy2010/article/details/50542664   ### 设计模式  ### ConcurrentHashMap 和 Hashtable 的区别ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。- **底层数据结构**： JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；- **实现线程安全的方式（重要）**： ① 在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 **Node 数组+链表+红黑树**的数据结构来实现，并发控制使用 **synchronized 和 CAS **来操作。   （JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；②** Hashtable(同一把锁)**:使用 **synchronized** 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。  ### 线程安全的集合类的实现原理汇总：- vector大部分方法包含关键字synchronized- concurrenthashmap利用synchronized+CAS保证线程安全，同时hashentry中的value值用valotile关键字修饰- copyonwriteList利用Reentrantlock对写加锁  ### myBatis+Spring+SpringMVC框架面试题整理  [myBatis+Spring+SpringMVC框架面试题整理(一)](https://blog.csdn.net/qq_41541619/article/details/82459873)  [myBatis+Spring+SpringMVC框架面试题整理(二)](https://blog.csdn.net/qq_41541619/article/details/82459965)  mybatis初始化要经过简单的以下几步：    1. 调用SqlSessionFactoryBuilder对象的build(inputStream)方法；    2. SqlSessionFactoryBuilder会根据输入流inputStream等信息创建XMLConfigBuilder对象;    3. SqlSessionFactoryBuilder调用XMLConfigBuilder对象的parse()方法；    4. XMLConfigBuilder对象返回Configuration对象；    5. SqlSessionFactoryBuilder根据Configuration对象创建一个DefaultSessionFactory对象；    6. SqlSessionFactoryBuilder返回 DefaultSessionFactory对象给Client，供Client使用。mybatis执行流程1. 加载配置文件并初始化(SqlSession)配置文件来源于两个地方，一个是配置文件(主配置文件conf.xml,mapper文件*.xml)，一个是java代码中的注释，将sql的配置信息加载成为一个mappedstatement对象，存储在内存之中（包括传入参数的映射配置，结果映射配置，执行的sql语句）。2. 接收调用请求调用mybatis提供的api，传入的参数为sql的id（有namespase和具体sql的id组成）和sql语句的参数对象，mybatis将调用请求交给请求处理层。3. 处理请求根据sql的id找到对应的mappedstatament对象。根据传入参数解析mappedstatement对象，得到最终要执行的sql。获取数据库连接，执行sql，得到执行结果Mappedstatement对象中的结果映射对执行结果进行转换处理，并得到最终的处理结果。释放连接资源4. 返回处理结果### JAVA中常用的一个编程技术：双重检查锁定，我们知道Object的wait和notify需要写在synchronized中，双重检查锁定就是除了在一开始判断item是否为null外，在synchonized内部再判断一次。  ### concurrrenthashmap原理  JDK8中ConcurrentHashMap参考了JDK8 HashMap的实现，采用了数组+链表+红黑树的实现方式来设计，内部大量采用CAS操作，这里我简要介绍下CAS。  CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和A的值是一样的，那么就将内存里面的值更新成B。CAS是通过无限循环来获取数据的，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要**自旋**，到下次循环才有可能机会执行。  #### JDK8中彻底放弃了Segment转而采用的是Node，其设计思想也不再是JDK1.7中的分段锁思想。  Node：保存key，value及key的hash值的数据结构。其中**value和next都用volatile**修饰，保证并发的**可见性**。    &lt;strong&gt;class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {    final int hash;    final K key;    volatile V val;    volatile Node&lt;K,V&gt; next;    //... 省略部分代码    }   Java8 ConcurrentHashMap结构基本上和Java8的HashMap一样，不过保证线程安全性。  #### 总结  从JDK1.7版本的**ReentrantLock+Segment+HashEntry**，到JDK1.8版本中**synchronized+CAS+HashEntry+红黑树**。- 1.数据结构：取消了Segment分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。- 2.保证线程安全机制：JDK1.7采用segment的分段锁机制实现线程安全，其中**segment继承自ReentrantLock**。**JDK1.8**采用**CAS+Synchronized保证线程安全**。- 3.锁的粒度：原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁（Node）。- 4.链表转化为红黑树:定位结点的hash算法简化会带来弊端,Hash冲突加剧,因此在链表节点数量大于**8**时，会将链表转化为红黑树进行存储。5.查询时间复杂度：从原来的遍历链表O(n)，变成遍历红黑树**O(logN)**。  ### java finalize方法总结、GC执行finalize的过程  ####  finalize的作用- finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。- finalize()与C++中的析构函数不是对应的。C++中的析构函数调用的时机是确定的（对象离开作用域或delete掉），但Java中的finalize的调用具有**不确定性**- 不建议用finalize方法完成“非内存资源”的清理工作，但建议用于：① 清理本地对象(通过JNI创建的对象)；② 作为确保某些非内存资源(如Socket、文件等)释放的一个补充：在finalize方法中显式调用其他资源释放方法。其原因可见下文[finalize的问题]  #### finalize的问题  - 一些与finalize相关的方法，由于一些致命的缺陷，已经被废弃了，如System.runFinalizersOnExit()方法、Runtime.runFinalizersOnExit()方法- System.gc()与System.runFinalization()方法增加了finalize方法执行的机会，但不可盲目依赖它们- Java语言规范并不保证finalize方法会被及时地执行、而且根本不会保证它们会被执行- finalize方法可能会带来性能问题。因为JVM通常在单独的低优先级线程中完成finalize的执行- 对象再生问题：finalize方法中，可将待回收对象赋值给GC Roots可达的对象引用，从而达到对象再生的目的- finalize方法**至多由GC执行一次**(用户当然可以手动调用对象的finalize方法，但并不影响GC对finalize的行为)  #### finalize的执行过程(生命周期)- (1) 首先，大致描述一下finalize流程：当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入**F-Queue**队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。- (2) 具体的finalize流程：对象可由两种状态，涉及到两类状态空间，一是终结状态空间 F = {unfinalized, finalizable, finalized}；二是可达状态空间 R = {reachable, finalizer-reachable, unreachable}。各状态含义如下： - unfinalized: 新建对象会先进入此状态，GC并未准备执行其finalize方法，因为该对象是可达的 - finalizable: 表示GC可对该对象执行finalize方法，GC已检测到该对象不可达。正如前面所述，GC通过F-Queue队列和一专用线程完成finalize的执行 - finalized: 表示GC已经对该对象执行过finalize方法 - reachable: 表示GC Roots引用可达 - finalizer-reachable(f-reachable)：表示不是reachable，但可通过某个finalizable对象可达 - unreachable：对象不可通过上面两种途径可达![](http://img.blog.csdn.net/20131006163937765)  - 变迁说明：    - 新建对象首先处于[reachable, unfinalized]状态(A) - 随着程序的运行，一些引用关系会消失，导致状态变迁，从reachable状态变迁到f-reachable(B, C, D)或unreachable(E, F)状态 - 若JVM检测到处于unfinalized状态的对象变成f-reachable或unreachable，JVM会将其标记为finalizable状态(G,H)。若对象原处于[unreachable, unfinalized]状态，则同时将其标记为f-reachable(H)。 - 在某个时刻，JVM取出某个finalizable对象，将其标记为finalized并在某个线程中执行其finalize方法。由于是在活动线程中引用了该对象，该对象将变迁到(reachable, finalized)状态(K或J)。该动作将影响某些其他对象从f-reachable状态重新回到reachable状态(L, M, N) - 处于finalizable状态的对象不能同时是unreahable的，由第4点可知，将对象finalizable对象标记为finalized时会由某个线程执行该对象的finalize方法，致使其变成reachable。这也是图中只有八个状态点的原因 - 程序员手动调用finalize方法并不会影响到上述内部标记的变化，因此JVM只会至多调用finalize一次，即使该对象“复活”也是如此。程序员手动调用多少次不影响JVM的行为 - 若JVM检测到finalized状态的对象变成unreachable，回收其内存(I) - 若对象并未覆盖finalize方法，JVM会进行优化，直接回收对象（O） - 注：System.runFinalizersOnExit()等方法可以使对象即使处于reachable状态，JVM仍对其执行finalize方法#### 代码示例</code></pre><p>public class GC {  </p><pre><code>public static GC SAVE_HOOK = null;  public static void main(String[] args) throws InterruptedException {    // 新建对象，因为SAVE_HOOK指向这个对象，对象此时的状态是(reachable,unfinalized)    SAVE_HOOK = new GC();      //将SAVE_HOOK设置成null，此时刚才创建的对象就不可达了，因为没有句柄再指向它了，对象此时状态是(unreachable，unfinalized)    SAVE_HOOK = null;      //强制系统执行垃圾回收，系统发现刚才创建的对象处于unreachable状态，并检测到这个对象的类覆盖了finalize方法，因此把这个对象放入F-Queue队列，由低优先级线程执行它的finalize方法，此时对象的状态变成(unreachable, finalizable)或者是(finalizer-reachable,finalizable)    System.gc();      // sleep，目的是给低优先级线程从F-Queue队列取出对象并执行其finalize方法提供机会。在执行完对象的finalize方法中的super.finalize()时，对象的状态变成(unreachable,finalized)状态，但接下来在finalize方法中又执行了SAVE_HOOK = this;这句话，又有句柄指向这个对象了，对象又可达了。因此对象的状态又变成了(reachable, finalized)状态。    Thread.sleep(500);     // 这里楼主说对象处于(reachable,finalized)状态应该是合理的。对象的finalized方法被执行了，因此是finalized状态。又因为在finalize方法是执行了SAVE_HOOK=this这句话，本来是unreachable的对象，又变成reachable了。     if (null != SAVE_HOOK) { //此时对象应该处于(reachable, finalized)状态          // 这句话会输出，注意对象由unreachable，经过finalize复活了。        System.out.println(&quot;Yes , I am still alive&quot;);      } else {          System.out.println(&quot;No , I am dead&quot;);      }      // 再一次将SAVE_HOOK放空，此时刚才复活的对象，状态变成(unreachable,finalized)    SAVE_HOOK = null;      // 再一次强制系统回收垃圾，此时系统发现对象不可达，虽然覆盖了finalize方法，但已经执行过了，因此直接回收。    System.gc();      // 为系统回收垃圾提供机会    Thread.sleep(500);      if (null != SAVE_HOOK) {          // 这句话不会输出，因为对象已经彻底消失了。        System.out.println(&quot;Yes , I am still alive&quot;);      } else {          System.out.println(&quot;No , I am dead&quot;);      }  }  @Override  protected void finalize() throws Throwable {      super.finalize();      System.out.println(&quot;execute method finalize()&quot;);     // 这句话让对象的状态由unreachable变成reachable，就是对象复活    SAVE_HOOK = this;  }  }   </code></pre><p>``` </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;java常见面试汇总&lt;br&gt;=&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/SnailClimb/JavaGuide/tree/master/docs/java&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考链接：javagui
      
    
    </summary>
    
    
      <category term="知识点汇总" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    
    
      <category term="知识点汇总" scheme="http://yoursite.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>blog</title>
    <link href="http://yoursite.com/2019/10/01/blog/"/>
    <id>http://yoursite.com/2019/10/01/blog/</id>
    <published>2019-10-01T10:38:36.000Z</published>
    <updated>2019-10-01T10:40:49.626Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="test" scheme="http://yoursite.com/categories/test/"/>
    
    
      <category term="test" scheme="http://yoursite.com/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/10/01/hello-world/"/>
    <id>http://yoursite.com/2019/10/01/hello-world/</id>
    <published>2019-10-01T07:15:08.159Z</published>
    <updated>2019-10-01T07:15:08.159Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
