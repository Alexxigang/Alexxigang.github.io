<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alexxigang</title>
  
  <subtitle>专注技术</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-10-01T13:32:35.854Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Alex</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>note_for_java</title>
    <link href="http://yoursite.com/2019/10/01/note-for-java/"/>
    <id>http://yoursite.com/2019/10/01/note-for-java/</id>
    <published>2019-10-01T13:27:16.000Z</published>
    <updated>2019-10-01T13:32:35.854Z</updated>
    
    <content type="html"><![CDATA[<p>java常见面试汇总<br>=</p><p><a href="https://gitee.com/SnailClimb/JavaGuide/tree/master/docs/java" target="_blank" rel="noopener">参考链接：javaguide</a><br><a href="https://snailclimb.gitee.io/javaguide/" target="_blank" rel="noopener">javaguide</a></p><h2 id="某大佬总结的java面试重点"><a href="#某大佬总结的java面试重点" class="headerlink" title="某大佬总结的java面试重点"></a>某大佬总结的java面试重点</h2><p>链接：<a href="https://www.nowcoder.com/discuss/123525" target="_blank" rel="noopener">https://www.nowcoder.com/discuss/123525</a></p><ul><li>Java基础（例如各种集合类，Java的特性，重写重载区别，equals和 hashcode的联系等等）  </li><li>数据库（主要是MySQL，最常问的例如索引，事务隔离级别等等）  </li><li>Spring（IOC,AOP的基础和底层例如cglib，jdk proxy等）  </li><li>计网和<em>*</em>作系统（这个有好多，但是重点的也就那些，比如三次握手四  次挥手，死锁，进程线程区别，线程的生命周期等）  </li><li>并发、JVM、线程池（把深入理解JVM的第2、3、7、最后两章看会感觉就足够  了，还有并发编程的艺术(这本没全看—，但是感觉面试经常问，比如原子 类，并发包工具等）</li><li>算法（面试个人感觉就是剑指offer的难度，遇到了好多原题，但是笔试  就得会贪心动态规划各种了虽然我不怎么会尴尬）</li><li>Redis、微服务（这个如果你简历上写了，面试官才会问，没写一般不  问）</li></ul><h3 id="牛客网汇总"><a href="#牛客网汇总" class="headerlink" title="牛客网汇总"></a>牛客网汇总</h3><ul><li><a href="https://www.nowcoder.com/discuss/94114" target="_blank" rel="noopener">阿里一面问题求指教</a>（阿里面试针对这个复习）  </li><li><a href="https://www.nowcoder.com/questionTerminal/6bd3857199564b3fb2d3fee4f4de06ea?toCommentId=1185246https://www.nowcoder.com/discuss/123525" target="_blank" rel="noopener">Java中的HashMap的工作原理是什么？</a>  </li><li><a href="https://www.nowcoder.com/discuss/97862" target="_blank" rel="noopener">360，阿里，美团，快手，贝壳，猫眼等面经及个人学习记录帖</a>  </li><li><a href="https://snailclimb.gitee.io/javaguide/#/essential-content-for-interview/BATJrealInterviewExperience/5%E9%9D%A2%E9%98%BF%E9%87%8C,%E7%BB%88%E8%8E%B7offer" target="_blank" rel="noopener">阿里五次面试面经</a></li></ul><h4 id="牛客网集锦整理"><a href="#牛客网集锦整理" class="headerlink" title="牛客网集锦整理"></a>牛客网集锦整理</h4><ul><li><a href="https://www.nowcoder.com/discuss/63072?type=post&amp;order=time&amp;pos=&amp;page=0" target="_blank" rel="noopener">后台开发常问面试题集锦（问题搬运工，附链接）</a> </li><li><a href="https://www.nowcoder.com/discuss/205303?type=5" target="_blank" rel="noopener">JAVA面试基础，看完应付9成面试问题</a>  </li><li><a href="https://www.nowcoder.com/discuss/221057?type=2" target="_blank" rel="noopener">面试必会的，一般开发能覆盖9成</a>  </li></ul><h4 id="师兄赠送面经"><a href="#师兄赠送面经" class="headerlink" title="师兄赠送面经"></a>师兄赠送面经</h4><p><a href="https://note.youdao.com/ynoteshare1/index.html?id=8d212c41b0d3f4852e584b7676cfe34b&amp;type=notebook" target="_blank" rel="noopener">师兄赠送面经</a></p><h4 id="亿万级数据处理的高效解决方案"><a href="#亿万级数据处理的高效解决方案" class="headerlink" title="亿万级数据处理的高效解决方案"></a>亿万级数据处理的高效解决方案</h4><ul><li><a href="https://www.nowcoder.com/discuss/150810?type=post&amp;order=time&amp;pos=&amp;page=1" target="_blank" rel="noopener">亿万级数据处理的高效解决方案</a>  </li></ul><h3 id="java中数据类型分为基本数据类型和引用数据类型。"><a href="#java中数据类型分为基本数据类型和引用数据类型。" class="headerlink" title="java中数据类型分为基本数据类型和引用数据类型。"></a>java中数据类型分为基本数据类型和引用数据类型。</h3><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><p>整型：byte，short，int，long<br>浮点型：float，double<br>字符型：char<br>布尔型：boolean</p><h4 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h4><p>数组<br>类<br>接口  </p><h4 id="Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按-值传递的"><a href="#Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按-值传递的" class="headerlink" title="Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按 值传递的"></a>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按 值传递的</h4><h3 id="在-Java-中定义一个不做事且没有参数的构造方法的作用"><a href="#在-Java-中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="在 Java 中定义一个不做事且没有参数的构造方法的作用"></a>在 Java 中定义一个不做事且没有参数的构造方法的作用</h3><p>Java 程序在执行子类的构造方法之前，如果没有用 super()来调用父类特  定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中  只定义了有参数的构造方法，而在子类的构造方法中又没有用 super()来  调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类  中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做  事且没有参数的构造方法。 　</p><h3 id="创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>创建一个对象用什么运算符?对象实体与对象引用有何不同?</h3><p>new运算符，new创建对象实例（对象实例在堆内存中），对象引用指向对象  实例（对象引用存放在栈内存中）。一个对象引用可以指向0个或1个对象  （一根绳子可以不系气球，也可以系一个气球）;一个对象可以有n个引用指  向它（可以用n条绳子系住一个气球）。  </p><h3 id="关于-final-关键字的一些总结"><a href="#关于-final-关键字的一些总结" class="headerlink" title="关于 final 关键字的一些总结"></a>关于 final 关键字的一些总结</h3><p>final关键字主要用在三个地方：变量、方法、类。<br>对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化  之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让  其指向另一个对象。<br>当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方  法都会被隐式地指定为final方法。<br>使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修  改它的含义；第二个原因是效率。在早期的Java实现版本中，会将final方  法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何  性能提升（现在的Java版本已经不需要使用final方法进行这些优化了）。  类中所有的private方法都隐式地指定为final。  </p><h3 id="为什么TCP客户端最后还要发送一次确认呢？"><a href="#为什么TCP客户端最后还要发送一次确认呢？" class="headerlink" title="为什么TCP客户端最后还要发送一次确认呢？"></a>为什么TCP客户端最后还要发送一次确认呢？</h3><p><strong>一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</strong><br>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一  个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于    TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服  务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数  据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服  务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务  器再次建立连接，这将导致不必要的错误和资源的浪费。<br>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受  到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由  于服务器收不到确认，就知道客户端并没有请求连接。<br><img src="https://img-blog.csdn.net/20170605110405666?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXpjc3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="三次握手">  </p><h3 id="为什么在四次挥手客户端最后还要等待2MSL？"><a href="#为什么在四次挥手客户端最后还要等待2MSL？" class="headerlink" title="为什么在四次挥手客户端最后还要等待2MSL？"></a>为什么在四次挥手客户端最后还要等待2MSL？</h3><p>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同  的MSL值。<br>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报  文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开  了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于  是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重  传的报文，接着给出回应报文，并且会重启2MSL计时器。<br>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现  在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可  以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连  接中不会出现旧连接的请求报文。  </p><h3 id="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手呢？"></a>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h3><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文  后，把ACK和SYN放在一个报文里发送给客户端。<br>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，<strong>也可以发送一些数据给对方后</strong>，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。  </p><h3 id="四-TCP-协议如何保证可靠传输"><a href="#四-TCP-协议如何保证可靠传输" class="headerlink" title="四 TCP 协议如何保证可靠传输"></a>四 TCP 协议如何保证可靠传输</h3><ul><li>应用数据被分割成 TCP 认为最适合发送的数据块。  </li><li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传  送给应用层。  </li><li>校验和： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。  </li><li>TCP的接收端会丢弃重复的数据。  </li><li>流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只  允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的  数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协  议是可变大小的滑动窗口协议。<strong>（TCP 利用滑动窗口实现流量控制）</strong></li><li>拥塞控制： 当网络拥塞时，减少数据的发送。  </li><li>ARQ协议： 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就  停止发送，等待对方确认。在收到确认后再发下一个分组。  </li><li>超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收  到这个报文段。如果不能及时收到一个确认，将重发这个报文段。<br><img src="https://img-blog.csdn.net/20170607205756255?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXpjc3U=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="三次握手"></li></ul><h3 id="五-接口与抽象的异同"><a href="#五-接口与抽象的异同" class="headerlink" title="五.接口与抽象的异同"></a>五.接口与抽象的异同</h3><h4 id="1-抽象类"><a href="#1-抽象类" class="headerlink" title="1.抽象类"></a>1.抽象类</h4><p>抽象类是关键字abstract修饰的类，既为抽象类，抽象抽象即不能被实例化。而不能被实例化就无用处，所以抽象类只能作为基类（父类），即被继承的类。抽象类中可以包含抽象方法也可以不包含，但具有抽象方法的类一定是抽象类。<br>　　抽象类的使用原则如下：</p><p>（1）被继承性：抽象方法必须为public或者protected（因为如果为private，则不能被子类继承，子类便无法实现该方法），缺省情况下默认为public；<br>（2）<strong>抽象性</strong>：抽象类不能直接实例化，需要依靠子类采用向上转型的方式处理；<br>（3）抽象类必须有子类，使用extends继承，一个子类只能继承一个抽象类；<br>（4）子类（如果不是抽象类）则<strong>必须覆写抽象类之中的全部抽象方法</strong>（如果子类没有实现父类的抽象方法，则必须将子类也定义为为abstract类。  </p><h4 id="1、接口与类相似点"><a href="#1、接口与类相似点" class="headerlink" title="1、接口与类相似点"></a>1、接口与类相似点</h4><p>一个接口可以有多个方法。<br>接口文件保存在 .java 结尾的文件中，文件名使用接口名。<br>接口的字节码文件保存在 .class 结尾的文件中。<br>接口相应的字节码文件必须在与包名称相匹配的目录结构中。</p><h4 id="2、接口与类的区别"><a href="#2、接口与类的区别" class="headerlink" title="2、接口与类的区别"></a>2、接口与类的区别</h4><p>接口不能用于实例化对象。<br>接口没有构造方法。<br>接口中所有的方法必须是抽象方法。<br>接口不能包含成员变量，除了 static 和 final 变量。<br>接口不是被类继承了，而是要被类实现。<br>接口支持多继承。</p><h4 id="3、接口特性"><a href="#3、接口特性" class="headerlink" title="3、接口特性"></a>3、接口特性</h4><p>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。<br>接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。<br>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。<br><img src="https://i.imgur.com/28uQkav.png" alt="接口与抽象类异同"><br><img src="https://i.imgur.com/mxRbvpg.png" alt></p><h3 id="六-static关键字"><a href="#六-static关键字" class="headerlink" title="六.static关键字"></a>六.static关键字</h3><ul><li>static关键字并不会改变变量和方法的访问权限。 与C/C++中的static不同，Java中的static关键字不会影响到变量或者方法的作用域。在Java中能够影响到访问权限的只有private、public、protected（包括包访问权限）这几个关键字。   </li><li>为什么说static块可以用来优化程序性能，是因为它的特性:只会在<strong>类加载的时候</strong>执行一次。 很多时候会将一些只需要进行一次的初始化操作都放在static代码块中进行 </li><li>static成员变量的初始化顺序按照定义的顺序进行初始化。  </li><li>即使没有显示地声明为static，<strong>类的构造器实际上也是静态方法</strong>。  </li><li>static方法一般称作静态方法，由于静态方法不依赖于任何对象就可以进行访问，因此对于静态方法来说，是没有this的，因为它不依附于任何对象，既然都没有对象，就谈不上this了。并且由于这个特性，在静态方法中不能访问类的非静态成员变量和非静态成员方法，因为非静态成员方法/变量都是必须依赖具体的对象才能够被调用。  </li><li><ul><li>static代码块也叫静态代码块，是在类中独立于类成员的static语句块，可以有多个，位置可以随便放，它不在任何的方法体内，<strong>JVM加载类时会执行这些静态的代码块</strong>，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。</li></ul></li><li>普通类是不允许声明为静态的，只有内部类才可以。</li></ul><p>被static修饰的内部类可以直接作为一个普通类来使用，而不需实例一个外部类  </p><ul><li>static能作用于局部变量么？</li></ul><p>　　在C/C++中static是可以作用域局部变量的，但是在Java中切记：<strong>static是不允许用来修饰局部变量</strong>。不要问为什么，这是Java语法的规定。  </p><ul><li>常见的笔试面试题    </li></ul><ol><li><p> public class Test extends Base{</p><p>  static{</p><pre><code> System.out.println(&quot;test static&quot;);</code></pre><p> }</p><p> public Test(){</p><pre><code> System.out.println(&quot;test constructor&quot;);</code></pre><p> }</p><p> public static void main(String[] args) {</p><pre><code> new Test();</code></pre><p> }<br> }</p><p>  class Base{</p><p> static{</p><pre><code> System.out.println(&quot;base static&quot;);</code></pre><p> }</p><p> public Base(){</p><pre><code> System.out.println(&quot;base constructor&quot;);</code></pre><p> }<br> }  </p></li></ol><p>输出：<br>        base static<br>         test static<br>         base constructor<br>         test constructor    </p><p>先来想一下这段代码具体的执行过程，在执行开始，先要寻找到main方法，因为main方法是程序的入口，但是在执行main方法之前，必须先加载Test类，而在加载Test类的时候发现Test类继承自Base类，因此会转去先加载Base类，在加载Base类的时候，发现有static块，便执行了static块。在Base类加载完成之后，便继续加载Test类，然后发现Test类中也有static块，便执行static块。在加载完所需的类之后，便开始执行main方法。在main方法中执行new Test()的时候会先调用父类的构造器，然后再调用自身的构造器。因此，便出现了上面的输出结果。</p><ul><li><p>static块可以出现类中的任何地方（只要不是方法内部，记住，任何方法内部都不行），并且执行是按照static块的顺序执行的。</p></li><li><p>这段代码的输出结果是什么？  </p><pre><code>    public class Test {    Person person = new Person(&quot;Test&quot;);    static{      System.out.println(&quot;test static&quot;);    }</code></pre></li></ul><pre><code>    public Test() {          System.out.println(&quot;test constructor&quot;);        }      public static void main(String[] args) {          new MyClass();      }}   class Person{        static{          System.out.println(&quot;person static&quot;);      }    public Person(String str) {  `        System.out.println(&quot;person &quot;+str);      }}   class MyClass extends Test {      Person person = new Person(&quot;MyClass&quot;);      static{          System.out.println(&quot;myclass static&quot;);      }    public MyClass() {          System.out.println(&quot;myclass constructor&quot;);      }   }     </code></pre><p>输出：</p><pre><code>` test static ` ` myclass static ` ` person static  `` person Test`` test constructor`` person MyClass`` myclass constructor`</code></pre><h5 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h5><p>首先加载Test类，因此会执行Test类中的static块。接着执行new MyClass()，而MyClass类还没有被加载，因此需要加载MyClass类。在加载MyClass类的时候，发现MyClass类继承自Test类，但是由于Test类已经被加载了，所以只需要加载MyClass类，那么就会执行MyClass类的中的static块。在加载完之后，就通过构造器来生成对象。而在生成对象的时候，<strong><em>必须先初始化父类的成员变量</em></strong>，因此会执行Test中的Person person = new Person()，而Person类还没有被加载过，因此会先加载Person类并执行Person类中的static块，接着执行父类的构造器，完成了父类的初始化，然后就来初始化自身了，因此会接着执行MyClass中的Person person = new Person()，最后执行MyClass的构造器。</p><h3 id="七-final"><a href="#七-final" class="headerlink" title="七.final"></a>七.final</h3><ul><li>根据程序上下文环境，Java关键字final有“这是无法改变的”或者“终态的”含义，它可以修饰非抽象类、非抽象类成员方法和变量。你可能出于两种理解而需要阻止改变：设计或效率。<pre><code>  final类不能被继承，没有子类，final类中的方法默认是final的。  final方法不能被子类的方法覆盖，但可以被继承。  final成员变量表示常量，只能被赋值一次，赋值后值不再改变。  final不能用于修饰构造方法。  注意：父类的private成员方法是不能被子类方法覆盖的，因此private类型的方法默认是final类型的。</code></pre></li><li>final类不能被继承，因此final类的成员方法没有机会被覆盖，默认都是final的。在设计类时候，如果这个类不需要有子类，类的实现细节不允许改变，并且确信这个类不会载被扩展，那么就设计为final类。</li><li>final方法<pre><code>  如果一个类不允许其子类覆盖某个方法，则可以把这个方法声明为final方法。  使用final方法的原因有二：  第一、把方法锁定，防止任何继承类修改它的意义和实现。  第二、高效。编译器在遇到调用final方法时候会转入内嵌机制，大大提高执行效率。</code></pre></li><li><p>final变量（常量）</p><pre><code>  用final修饰的成员变量表示常量，值一旦给定就无法改变！  final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。  从下面的例子中可以看出，一旦给final变量初值后，值就不能再改变了。  另外，final变量定义的时候，可以先声明，而不给初值，这中变量也称为final空白，无论什么情况，编译器都确保空白final在使用之前必须被初始化。但是，final空白在final关键字final的使用上提供了更大的灵活性，为此，一个类中的final数据成员就可以实现依对象而有所不同，却有保持其恒定不变的特征。</code></pre></li><li><p>static和final一块用表示什么</p><pre><code>  static final用来修饰成员变量和成员方法，可简单理解为“全局常量”！  对于变量，表示一旦给值就不可修改，并且通过类名可以访问。  对于方法，表示不可覆盖，并且可以通过类名直接访问。  ** 特别要注意一个问题： **  对于被static和final修饰过的实例常量，实例本身不能再改变了，但**对于一些容器类型（比如，ArrayList、HashMap）的实例变量，不可以改变容器变量本身，但可以修改容器中存放的对象，**这一点在编程中用到很多。</code></pre></li></ul><h3 id="八-Java关键字this、super使用总结"><a href="#八-Java关键字this、super使用总结" class="headerlink" title="八.Java关键字this、super使用总结"></a>八.Java关键字this、super使用总结</h3><h4 id="一、this"><a href="#一、this" class="headerlink" title="一、this"></a>一、this</h4><p>Java关键字this只能用于方法方法体内。当一个对象创建后，<br>Java虚拟机（JVM）就会给这个对象分配一个引用自身的指针，这个指针的名字就是this。因此，this只能在类中的非静态方法中使用，静态方法和静态的代码块中绝对不能出现this，这在“Java关键字static、final使用总结”一文中给出了明确解释。并且this只和特定的对象关联，而不和类关联，同一个类的不同对象有不同的this。  </p><ul><li><p>在什么情况下需要用到this：</p><pre><code>  第一、通过this调用另一个构造方法，用发是this(参数列表)，这个仅仅在类的构造方法中，别的地方不能这么用。  第二、函数参数或者函数中的局部变量和成员变量同名的情况下，成员变量被屏蔽，此时要访问成员变量则需要用“this.成员变量名”的方式来引用成员变量。当然，在没有同名的情况下，可以直接用成员变量的名字，而不用this，用了也不为错，呵呵。  第三、在函数中，需要引用该函所属类的当前对象时候，直接用this。</code></pre><h4 id="二、super"><a href="#二、super" class="headerlink" title="二、super"></a>二、super</h4><pre><code>  super关键和this作用类似，是被屏蔽的成员变量或者成员方法  或变为可见，或者说用来引用被屏蔽的成员变量和成员成员方法。</code></pre><p>不过super是用在子类中，目的是访问直接父类中被屏蔽的成员，注意是直接父类（就是类之上最近的超类）。  </p></li><li><p>总结一下super的用法：</p><pre><code>  第一、在子类构造方法中要调用父类的构造方法，用“super(参数列表)”的方式调用，参数不是必须的。同时还要注意的一点是：**“super(参数列表)”这条语句只能用在子类构造方法体中的第一行。**  第二、当子类方法中的局部变量或者子类的成员变量与父类成员变量同名时，也就是子类局部变量覆盖父类成员变量时，用“super.成员变量名”来引用父类成员变量。当然，如果父类的成员变量没有被覆盖，也可以用“super.成员变量名”来引用父类成员变量，不过这是不必要的。  第三、当子类的成员方法覆盖了父类的成员方法时，也就是子类和父类有完全相同的方法定义（但方法体可以不同），此时，用“super.方法名(参数列表)”的方式访问父类的方法。  </code></pre><h3 id="九-java中的匿名内部类总结"><a href="#九-java中的匿名内部类总结" class="headerlink" title="九.java中的匿名内部类总结"></a>九.java中的匿名内部类总结</h3><p>匿名内部类也就是没有名字的内部类</p></li></ul><p>正因为没有名字，所以匿名内部类只能使用一次，它通常用来简化代码编写</p><p>但使用匿名内部类还有个<strong>前提条件：必须继承一个父类或实现一个接口</strong>  </p><h4 id="匿名内部类的基本实现"><a href="#匿名内部类的基本实现" class="headerlink" title="匿名内部类的基本实现"></a>匿名内部类的基本实现</h4><pre><code>abstract class Person {public abstract void eat();}public class Demo {public static void main(String[] args) {    Person p = new Person() {        public void eat() {            System.out.println(&quot;eat something&quot;);        }    };    p.eat();}}  </code></pre><p>可以看到，我们直接将抽象类Person中的方法在大括号中实现了</p><p>这样便可以省略一个类的书写</p><p>并且，匿名内部类还能用于接口上</p><h4 id="在接口上使用匿名内部类"><a href="#在接口上使用匿名内部类" class="headerlink" title="在接口上使用匿名内部类"></a>在接口上使用匿名内部类</h4><pre><code>interface Person {public void eat();}public class Demo {public static void main(String[] args) {    Person p = new Person() {        public void eat() {            System.out.println(&quot;eat something&quot;);        }    };    p.eat();}}  </code></pre><p>由上面的例子可以看出，只要一个类是抽象的或是一个接口，那么其子类中的方法都可以使用匿名内部类来实现</p><p>最常用的情况就是在多线程的实现上，因为要实现多线程必须继承Thread类或是继承Runnable接口</p><h4 id="Thread类的匿名内部类实现"><a href="#Thread类的匿名内部类实现" class="headerlink" title="Thread类的匿名内部类实现"></a>Thread类的匿名内部类实现</h4><pre><code>public class Demo {public static void main(String[] args) {    Thread t = new Thread() {        public void run() {            for (int i = 1; i &lt;= 5; i++) {                System.out.print(i + &quot; &quot;);            }        }    };    t.start();}}  </code></pre><h4 id="Runnable接口的匿名内部类实现"><a href="#Runnable接口的匿名内部类实现" class="headerlink" title="Runnable接口的匿名内部类实现"></a>Runnable接口的匿名内部类实现</h4><pre><code>public class Demo {public static void main(String[] args) {    Runnable r = new Runnable() {        public void run() {            for (int i = 1; i &lt;= 5; i++) {                System.out.print(i + &quot; &quot;);            }        }    };    Thread t = new Thread(r);    t.start();}}  </code></pre><h3 id="垃圾回收算法原理"><a href="#垃圾回收算法原理" class="headerlink" title="垃圾回收算法原理"></a>垃圾回收算法原理</h3><p>转载自：<a href="https://blog.csdn.net/FateRuler/article/details/81158510" target="_blank" rel="noopener">https://blog.csdn.net/FateRuler/article/details/81158510</a> </p><h4 id="第一种：标记清除"><a href="#第一种：标记清除" class="headerlink" title="第一种：标记清除"></a>第一种：标记清除</h4><p>它是最基础的收集算法。<br>原理：分为标记和清除两个阶段：首先标记出所有的需要回收的对象，在标记完成以后统一回收所有被标记的对象。<br>特点：（1）效率问题，标记和清除的效率都不高；（2）空间的问题，标记清除以后会产生大量不连续的空间碎片，空间碎片太多可能会导致程序运行过程需要分配较大的对象时候，无法找到足够连续内存而不得不提前触发一次垃圾收集。<br>地方 ：适合在老年代进行垃圾回收，比如CMS收集器就是采用该算法进行回收的。</p><h4 id="第二种：标记整理"><a href="#第二种：标记整理" class="headerlink" title="第二种：标记整理"></a>第二种：标记整理</h4><p>原理：分为标记和整理两个阶段：首先标记出所有需要回收的对象，让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。<br>特点：不会产生空间碎片，但是整理会花一定的时间。<br>地方：适合老年代进行垃圾收集，parallel Old（针对parallel scanvange gc的） gc和Serial old收集器就是采用该算法进行回收的。</p><h4 id="第三种：复制算法"><a href="#第三种：复制算法" class="headerlink" title="第三种：复制算法"></a>第三种：复制算法</h4><p>原理：它先将可用的内存按容量划分为大小相同的两块，每次只是用其中的一块。当这块内存用完了，就将还存活着的对象复制到另一块上面，然后把已经使用过的内存空间一次清理掉。<br>特点：没有内存碎片，只要移动堆顶指针，按顺序分配内存即可。代价是将内存缩小位原来的一半。<br>地方：适合新生代区进行垃圾回收。serial new，parallel new和parallel scanvage<br>收集器，就是采用该算法进行回收的。</p><h4 id="复制算法改进思路："><a href="#复制算法改进思路：" class="headerlink" title="复制算法改进思路："></a>复制算法改进思路：</h4><p>由于新生代都是朝生夕死的，所以不需要1：1划分内存空间，可以将内存划分为一块较大的Eden和两块较小的Suvivor空间。每次使用Eden和其中一块Survivor。当回收的时候，将Eden和Survivor中还活着的对象一次性地复制到另一块Survivor空间上，最后清理掉Eden和刚才使用过的Suevivor空间。其中Eden和Suevivor的大小比例是8：1。缺点是需要老年代进行分配担保，如果第二块的Survovor空间不够的时候，需要对老年代进行垃圾回收，然后存储新生代的对象，这些新生代当然会直接进入来老年代。</p><p>优化收集方法的思路<br>分代收集算法<br>原理：根据对象存活的周期的不同将内存划分为几块，然后再选择合适的收集算法。<br>一般是把java堆分成新生代和老年代，这样就可以根据各个年待的特点采用最适合的收集算法。在新生代中，每次垃圾收集都会有大量的对象死去，只有少量存活，所以选用复制算法。老年代因为对象存活率高，没有额外空间对他进行分配担保，所以一般采用标记整理或者标记清除算法进行回收。</p><p>对于以上两种标记算法存在争议，在深入了解JVM最佳实践第二版中，是写的标记需要回收的对象，我也没太深入思考，直到有人提出来，我也去查了一下和想了一下。我个人现在偏向，标记存活的对象。<br><strong>标记算法的大概流程：通过引用链给所有存活的对象做个标记，然后回收所有没有标记的对象 和 清除存活对象的标记，等待下一次GC</strong></p><h3 id="GC用的引用可达性分析算法中，哪些对象可作为GC-Roots对象"><a href="#GC用的引用可达性分析算法中，哪些对象可作为GC-Roots对象" class="headerlink" title="GC用的引用可达性分析算法中，哪些对象可作为GC Roots对象"></a>GC用的引用可达性分析算法中，哪些对象可作为GC Roots对象</h3><p>先说一下可达性分析算法的思想：从一个被称为GC Roots的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。</p><h4 id="在java中可以作为GC-Roots的对象有以下几种："><a href="#在java中可以作为GC-Roots的对象有以下几种：" class="headerlink" title="在java中可以作为GC Roots的对象有以下几种："></a>在java中可以作为GC Roots的对象有以下几种：</h4><p>转载自：<a href="https://blog.csdn.net/ma345787383/article/details/77099522" target="_blank" rel="noopener">https://blog.csdn.net/ma345787383/article/details/77099522</a> </p><p>虚拟机栈中引用的对象、方法区类静态属性引用的对象、方法区常量池引用的对象、本地方法栈JNI引用的对象<br>虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象 <strong>不一定会被回收。</strong>当一个对象不可达GC Roots时，这个对象并不会马上被回收，而是处于一个死缓的阶段，<strong>若要被真正的回收需要经历两次标记。</strong>如果对象在可达性分析中没有与GC Roots的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行finalize()方法。当对象没有覆盖finalize()方法或者已经被虚拟机调用过，那么就认为是没必要的。<br>如果该对象有必要执行finalize()方法，那么这个对象将会放在一个称为F-Queue的队列中，虚拟机会触发一个finalize()线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这还是因为如果finalize()执行缓慢或者发生了死锁，那么就会造成F-Queue队列一直等待，造成了内存回收系统的崩溃。GC对处于F-Queue中的对象进行第二次被标记，这时，该对象将被移除“即将回收”集合，等待回收。</p><h3 id="hashmap中key是否可以为null"><a href="#hashmap中key是否可以为null" class="headerlink" title="hashmap中key是否可以为null"></a>hashmap中key是否可以为null</h3><p>1、 HashMap计算key的hash值时调用单独的方法，在该方法中会判断key是否为null，如果是则返回0；而Hashtable中则直接调用key的hashCode()方法，因此如果key为null，则抛出空指针异常。</p><p>2、 HashMap将键值对添加进数组时，不会主动判断value是否为null；而Hashtable则首先判断value是否为null。</p><p>3、以上原因主要是由于Hashtable继承自Dictionary，而HashMap继承自AbstractMap。</p><p>4、虽然ConcurrentHashMap也继承自AbstractMap，但是其也过滤掉了key或value为null的键值对。  </p><ul><li>JDK1.8 之前 HashMap 底层是 数组和链表 结合在一起使用也就是 链表散列。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过<strong>(n - 1) &amp; hash</strong> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</li></ul><p>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</p><h3 id="十-基本数据类型和对象的区别"><a href="#十-基本数据类型和对象的区别" class="headerlink" title="十.基本数据类型和对象的区别"></a>十.基本数据类型和对象的区别</h3><p>(1) 基本数据类型的存储原理：所有的简单数据类型不存在“引用”的概念，基本数据类型都是直接存储在内存中的栈上的，数据本身的值就是存储在栈空间里面，Java语言里面八种数据类型是这种存储模型；</p><p>(2) 引用类型的存储原理：引用类型继承于Object类（也是引用类型）都是按照Java里面存储对象的内存模型来进行数据存储的，使用Java堆和栈来进行这种类型的数据存储，简单地讲，“引用”(存储对象在内存堆上的地址)是存储在有序的栈上的，而对象本身的值存储在堆上的；</p><p>不论是基本数据类型还是引用类型，他们都会先在栈中分配一块内存，对于基本类型来说，这块区域包含的是基本类型的内容；而对于引用类型来说，这块区域包含的是指向真正内容的指针，真正的内容被手动的分配在堆上。  </p><h3 id="Synchronized的使用"><a href="#Synchronized的使用" class="headerlink" title="Synchronized的使用"></a>Synchronized的使用</h3><h4 id="synchronized的三种应用方式"><a href="#synchronized的三种应用方式" class="headerlink" title="synchronized的三种应用方式"></a>synchronized的三种应用方式</h4><p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础： </p><ol><li>普通同步方法（实例方法），锁是当前实例对象 ，进入同步代码前要获得当前实例的锁   </li><li>静态同步方法，锁是当前类的class对象 ，进入同步代码前要获得当前类对象的锁   </li><li>同步方法块，锁是<strong>括号里面的对象</strong>，对给定对象加锁，进入同步代码库前要获得给定对象的锁。   <h4 id="一个类中存在一个synchronized修饰的方法和一个普通的方法，不同线程同时访问这两个方法，会出现什么情况？"><a href="#一个类中存在一个synchronized修饰的方法和一个普通的方法，不同线程同时访问这两个方法，会出现什么情况？" class="headerlink" title="一个类中存在一个synchronized修饰的方法和一个普通的方法，不同线程同时访问这两个方法，会出现什么情况？"></a>一个类中存在一个synchronized修饰的方法和一个普通的方法，不同线程同时访问这两个方法，会出现什么情况？</h4></li></ol><ul><li><p>一个线程持有对象锁，另一个线程可以以异步的方式调用对象里面的非synchronized方法，输出结果是不按照顺序的</p></li><li><p>一个线程持有对象锁，另一个线程可以以同步的方式调用对象里面的synchronized方法，需要等待上一个线程释放资源，也就是同步。  </p></li><li>两个线程访问不同对象中不同的synchronized方法不会受到synchronized的限制  <h3 id="Java常见的几种内存溢出及解决方案"><a href="#Java常见的几种内存溢出及解决方案" class="headerlink" title="Java常见的几种内存溢出及解决方案"></a>Java常见的几种内存溢出及解决方案</h3></li><li><p>1.JVM Heap（堆）溢出：java.lang.OutOfMemoryError: Java heap space</p><p>   JVM在启动的时候会自动设置JVM Heap的值， 可以利用JVM提供的-Xmn -Xms -Xmx等选项可进行设置。Heap的大小是Young Generation 和Tenured Generaion 之和。在JVM中如果98%的时间是用于GC,且可用的Heap size 不足2%的时候将抛出此异常信息。<br>解决方法：手动设置JVM Heap（堆）的大小。<br>Java堆用于储存对象实例。当需要为对象实例分配内存，而堆的内存占用又已经达到-Xmx设置的最大值。将会抛出OutOfMemoryError异常。  </p></li><li>2.PermGen space溢出： java.lang.OutOfMemoryError: PermGen space<br>   PermGen space的全称是Permanent Generation space，是指内存的永久保存区域。为什么会内存溢出，这是由于这块内存主要是被JVM存放Class和Meta信息的，Class在被Load的时候被放入PermGen space区域，它和存放Instance的Heap区域不同，sun的 GC不会在主程序运行期对PermGen space进行清理，所以如果你的APP会载入很多CLASS的话，就很可能出现PermGen space溢出。一般发生在程序的启动阶段。<br>解决方法： 通过-XX:PermSize和-XX:MaxPermSize设置永久代大小即可。<br>   方法区用于存放java类型的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。在类装载器加载class文件到内存的过程中，虚拟机会提取其中的类型信息，并将这些信息存储到方法区。当需要存储类信息而方法区的内存占用又已经达到-XX:MaxPermSize设置的最大值，将会抛出OutOfMemoryError异常。  </li><li>3.栈溢出： java.lang.StackOverflowError : Thread Stack space<pre><code>栈溢出了，JVM依然是采用栈式的虚拟机，这个和C和Pascal都是一样的。函数的调用过程都体现在堆栈和退栈上了。调用构造函数的 “层”太多了，以致于把栈区溢出了。 通常来讲，一般栈区远远小于堆区的，因为函数调用过程往往不会多于上千层，而即便每个函数调用需要 1K的空间（这个大约相当于在一个C函数内声明了256个int类型的变量），那么栈区也不过是需要1MB的空间。通常栈的大小是1-2MB的。通俗一点讲就是单线程的程序需要的内存太大了。 通常递归也不要递归的层次过多，很容易溢出。</code></pre>解决方法：1：修改程序。2：通过 -Xss: 来设置每个线程的Stack大小即可。<br>在Java虚拟机规范中，对这个区域规定了两种异常状况：StackOverflowError和OutOfMemoryError异常。</li></ul><ul><li><p>（1）StackOverflowError异常</p><pre><code> 每当java程序代码启动一个新线程时，Java虚拟机都会为它分配一个Java栈。Java栈以帧为单位保存线程的运行状态。当线程调用java方法时，虚拟机压入一个新的栈帧到该线程的java栈中。只要这个方法还没有返回，它就一直存在。如果线程的方法嵌套调用层次太多(如递归调用)，随着java栈中帧的逐渐增多，最终会由于该线程java栈中所有栈帧大小总和大于-Xss设置的值，而产生StackOverflowError内存溢出异常。  </code></pre><p>（2）OutOfMemoryError异常<br>  java程序代码启动一个新线程时，没有足够的内存空间为该线程分配java    栈(一个线程java栈的大小由-Xss参数确定)，jvm则抛出OutOfMemoryError异常。  </p></li></ul><ul><li>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。<br>•    StackOverFlowError： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 异常。<br>•    OutOfMemoryError： 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出 OutOfMemoryError 异常。</li></ul><h3 id="十一-内存泄漏"><a href="#十一-内存泄漏" class="headerlink" title="十一.内存泄漏"></a>十一.内存泄漏</h3><ul><li>内存泄漏与内存溢出的关系：  <pre><code>内存泄漏的堆积最终会导致内存溢出</code></pre>  内存溢出就是你要的内存空间超过了系统实际分配给你的空间，此时系  统相当于没法满足你的需求，就会报内存溢出的错误。<br>  内存泄漏是指你向系统申请分配内存进行使用(new)，可是使用完了以  后却不归还(delete)，结果你申请到的那块内存你自己也不能再访问  （也许你把它的地址给弄丢了），而系统也不能再次将它分配给需要的  程序。就相当于你租了个带钥匙的柜子，你存完东西之后把柜子锁上之  后，把钥匙丢了或者没有将钥匙还回去，那么结果就是这个柜子将无法  供给任何人使用，也无法被垃圾回收器回收，因为找不到他的任何信  息。<br>  内存溢出：一个盘子用尽各种方法只能装4个果子，你装了5个，结果掉  倒地上不能吃了。这就是溢出。比方说栈，栈满时再做进栈必定产生空  间溢出，叫上溢，栈空时再做退栈也产生空间溢出，称为下溢。就是分  配的内存不足以放下数据项序列,称为内存溢出。说白了就是我承受不了  那么多，那我就报错，  <h4 id="内存泄漏的几种情况："><a href="#内存泄漏的几种情况：" class="headerlink" title="内存泄漏的几种情况："></a>内存泄漏的几种情况：</h4></li><li>1、<strong>静态集合类</strong>，如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与程序一致，则容器中的对象在程序结束之前将不能被释放，从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。</li><li>2、<strong>各种连接</strong>，如数据库连接、网络连接和IO连接等。在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。</li><li><p>3、<strong>变量不合理的作用域</strong>。一般而言，一个变量的定义的作用范围大于其使用范围，很有可能会造成内存泄漏。另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生。  </p><pre><code>  public class UsingRandom {      private String msg;      public void receiveMsg(){          readFromNet();// 从网络中接受数据保存到msg中          saveDB();// 把msg保存到数据库中      }  }  </code></pre><p>如上面这个伪代码，通过readFromNet方法把接受的消息保存在变量msg  中，然后调用saveDB方法把msg的内容保存到数据库中，此时msg已经就没  用了，由于msg的生命周期与对象的生命周期相同，此时msg还不能回收，因  此造成了内存泄漏。<br>实际上这个msg变量可以放在receiveMsg方法内部，当方法使用完，那么  msg的生命周期也就结束，此时就可以回收了。还有一种方法，在使用完msg  后，把msg设置为null，这样垃圾回收器也会回收msg的内存空间。  </p></li><li>4、内部类持有外部类，如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。</li><li>5、改变哈希值，当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露  <h3 id="Java中常见的几种RuntimeException"><a href="#Java中常见的几种RuntimeException" class="headerlink" title="Java中常见的几种RuntimeException"></a>Java中常见的几种RuntimeException</h3><h4 id="JAVA中常见的几种RuntimeException-大约有如下几种："><a href="#JAVA中常见的几种RuntimeException-大约有如下几种：" class="headerlink" title="JAVA中常见的几种RuntimeException,大约有如下几种："></a>JAVA中常见的几种RuntimeException,大约有如下几种：</h4>NullPointerException - 空指针引用异常<br>ClassCastException - 类型强制转换异常。<br>IllegalArgumentException - 传递非法参数异常。<br>ArithmeticException - 算术运算异常<br>ArrayStoreException - 向数组中存放与声明类型不兼容对象异常<br>IndexOutOfBoundsException - 下标越界异常<br>NegativeArraySizeException - 创建一个大小为负数的数组错误异常<br>NumberFormatException - 数字格式异常<br>SecurityException - 安全异常<br>UnsupportedOperationException - 不支持的操作异常    <h4 id="常见的RuntimeException"><a href="#常见的RuntimeException" class="headerlink" title="常见的RuntimeException"></a>常见的RuntimeException</h4>RuntimeException是开发中最容易遇到的，下面列举一下常见的RuntimeException：    </li></ul><ul><li>1、NullPointerException：见的最多了，其实很简单，一般都是在null对象上调用方法了。  <pre><code>        String s=null;  boolean eq=s.equals(&quot;&quot;); // NullPointerException   </code></pre> 这里你看的非常明白了，为什么一到程序中就晕呢？  <pre><code> public int getNumber(String str){</code></pre>  　　if(str.equals(“A”)) return 1;<br>  　　 else if(str.equals(“B”)) return 2;<pre><code> }  </code></pre> 这个方法就有可能抛出NullPointerException,我建议你主动抛出异常，因为代码一多，你可能又晕了。<br> public int getNumber(String str){<br>　　if(str==null) throw new NullPointerException(“参数不能为空”);<pre><code>                             //你是否觉得明白多了</code></pre>　　if(str.equals(“A”)) return 1;<br>　　    else if(str.equals(“B”)) return 2;<br> }   </li><li>2、NumberFormatException：继承IllegalArgumentException，字符串转换为数字时出现。比如int i= Integer.parseInt(“ab3”);  </li><li>3、ArrayIndexOutOfBoundsException:数组越界。比如 int[] a=new int[3]; int b=a[3];  </li><li>4、StringIndexOutOfBoundsException：字符串越界。比如 String s=”hello”; char c=s.chatAt(6);  </li><li>5、ClassCastException:类型转换错误。比如 Object obj=new Object(); String s=(String)obj;  </li><li>6、UnsupportedOperationException:该操作不被支持。如果我们希望不支持这个方法，可以抛出这个异常。既然不支持还要这个干吗？有可能子类中不想支持父类中有的方法，可以直接抛出这个异常。  </li><li>7、ArithmeticException：算术错误，典型的就是0作为除数的时候。  </li><li>8、IllegalArgumentException：非法参数，在把字符串转换成数字的时候经常出现的一个异常，我们可以在自己的程序中好好利用这个异常。</li></ul><h3 id="java中hashmap的原理"><a href="#java中hashmap的原理" class="headerlink" title="java中hashmap的原理"></a>java中hashmap的原理</h3><h4 id="较详细链接（评论里也有详细解答）"><a href="#较详细链接（评论里也有详细解答）" class="headerlink" title="较详细链接（评论里也有详细解答）"></a>较详细链接（评论里也有详细解答）</h4><p><a href="https://www.nowcoder.com/questionTerminal/6bd3857199564b3fb2d3fee4f4de06ea?toCommentId=1185246" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/6bd3857199564b3fb2d3fee4f4de06ea?toCommentId=1185246</a><br>链接：<a href="https://www.nowcoder.com/questionTerminal/6bd3857199564b3fb2d3fee4f4de06ea?toCommentId=1185246" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/6bd3857199564b3fb2d3fee4f4de06ea?toCommentId=1185246</a><br>来源：牛客网</p><p>hashmap是一个key-value键值对的数据结构，从结构上来讲在jdk1.8之  前是用数组加链表的方式实现，jdk1.8加了红黑树，hashmap数组的默认初  始长度是16，hashmap数组只允许一个key为null，允许多个value为null<br>hashmap的内部实现，hashmap是使用数组+链表+红黑树的形式实现的，  其中数组是一个一个Node[]数组，我们叫他hash桶数组，它上面存放的是  key-value键值对的节点。HashMap是用hash表来存储的，在hashmap里  为解决hash冲突，使用链地址法，简单来说就是数组加链表的形式来解决  ，当数据被hash后，得到数组下标，把数据放在对应下表的链表中。<br>然后再说一下hashmap的方法实现<br>put方法，put方法的第一步，就是计算出要put元素在hash桶数组中的索引  位置，得到索引位置需要三步，去put元素key的hashcode值，高位运算，  取模运算，高位运算就是用第一步得到的值h，用h的高16位和低16位进行异  或操作，第三步为了使hash桶数组元素分布更均匀，采用取模运算，取模运  算就是用第二步得到的值和hash桶数组长度-1的值取与。这样得到的结果和  传统取模运算结果一致，而且效率比取模运算高<br>jdk1.8中put方法的具体步骤，先判断hashmap是否为空，为空的话扩容，  不为空计算出key的hash值i，然后看table[i]是否为空，为空就直接插  入，不为空判断当前位置的key和table[i]是否相同，相同就覆盖，不相同  就查看table[i]是否是红黑树节点，如果是的话就用红黑树直接插入键值    对，如果不是开始遍历链表插入，如果遇到重复值就覆盖，否则直接插入，  如果链表长度大于8，转为红黑树结构，执行完成后看size是否大于阈值  threshold，大于就扩容，否则直接结束<br>get方法就是计算出要获取元素的hash值，去对应位置取即可。<br>扩容机制，hashmap的扩容中主要进行两部，第一步把数组长度变为原来的 两倍，第二部把旧数组的元素重新计算hash插入到新数组中，在jdk1.8时，不用重新计算hash，只用看看原来的hash值新增的一位是零还是1，如果是1这个元素在新数组中的位置，是原数组的位置加原数组长度，如果是零就插入到原数组中。扩容过程第二部一个非常重要的方法是transfer方法，采用头插法，把旧数组的元素插入到新数组中。<br>3.hashmap大小为什么是2的幂次方<br>在计算插入元素在hash桶数组的索引时第三步，为了使元素分布的更加均匀，用取模操作，但是传统取模操作效率低，然后优化成h&amp;(length-1)，设置成2幂次方，是因为2的幂次方-1后的值每一位上都是1，然后与第二步计算出的h值与的时候，最终的结果只和key的hashcode值本身有关，这样不会造成空间浪费并且分布均匀，如果不是2的幂次方<br>如果length不为2的幂，比如15。那么length-1的2进制就会变成1110。在h为随机数的情况下，和1110做&amp;操作。尾数永远为0。那么0001、1001、1101等尾数为1的位置就永远不可能被entry占用。这样会造成浪费，不随机等问题。  </p><h3 id="spring"><a href="#spring" class="headerlink" title="spring"></a>spring</h3><h4 id="1-单例及线程安全"><a href="#1-单例及线程安全" class="headerlink" title="1.单例及线程安全"></a>1.单例及线程安全</h4><p>spring依赖注入时，使用了双重判断加锁的单例模式，首先从缓存中获取bean实例，如果为null，对缓存map加锁，然后再从缓存中获取bean，如果继续为null，就创建一个bean。这样双重判断，能够避免在加锁的瞬间，有其他依赖注入引发bean实例的创建，从而造成重复创建的结果</p><h3 id="java静态方法不能调用非静态方法的原因"><a href="#java静态方法不能调用非静态方法的原因" class="headerlink" title="java静态方法不能调用非静态方法的原因"></a>java静态方法不能调用非静态方法的原因</h3><p>静态方法是属于类的，即静态方法是随着类的加载而加载的，在加载类时，程序就会为静态方法分配内存，而非静态方法是属于对象的，对象是在类加载之后创建的，也就是说静态方法先于对象存在，当你创建一个对象时，程序为其在堆中分配内存，一般是通过this指针来指向该对象。静态方法不依赖于对象的调用，它是通过‘类名.静态方法名’这样的方式来调用的。而对于非静态方法，在对象创建的时候程序才会为其分配内存，然后通过类的对象去访问非静态方法。因此在对象未存在时非静态方法也不存在，静态方法自然不能调用一个不存在的方法  </p><h3 id="JDK1-8新特性"><a href="#JDK1-8新特性" class="headerlink" title="JDK1.8新特性"></a>JDK1.8新特性</h3><ul><li>Lambda表达式</li><li>函数式接口</li><li>方法引用和构造器调用</li><li>Stream API</li><li>接口中的默认方法和静态方法</li><li>新时间日期API</li><li>default关键字<br>在jdk1.8中对hashMap等map集合的数据结构优化。hashMap数据结构的优化<br>原来的hashMap采用的数据结构是哈希表（数组+链表），hashMap默认大小是16，一个0-15索引的数组，如何往里面存储元素，首先调用元素的hashcode 方法，计算出哈希码值，经过哈希算法算成数组的索引值，如果对应的索引处没有元素，直接存放，如果有对象在，那么比较它们的equals方法比较内容<br>如果内容一样，后一个value会将前一个value的值覆盖，如果不一样，在1.7的时候，后加的放在前面，形成一个链表，形成了碰撞，在某些情况下如果链表 无限下去，那么效率极低，碰撞是避免不了的<br>加载因子：0.75，数组扩容，达到总容量的75%，就进行扩容，但是无法避免碰撞的情况发生<br>在1.8之后，在数组+链表+红黑树来实现hashmap，当碰撞的元素个数大于8时 &amp; 总容量大于64，会有<strong>红黑树</strong>的引入 除了添加之后，效率都比链表高，<strong>在jdk1.8之前是插入头部的，在jdk1.8中是插入尾部的。1.8之后链表新进元素加到末尾，</strong>在jdk1.6中，HashMap中有个内置Entry类，它  实现了Map.Entry接口；而在jdk1.8中，这个Entry类不见了，变成了  <strong>Node类</strong>，也实现了Map.Entry接口，与jdk1.6中的Entry是等价的。<br>红黑树插入：超过这个阈值后HashMap开始将列表升级成一个二叉树，，使用哈希值作为树的分支变量，如果两个哈希值不等，但指向同一个桶的话，较大的那个会插入到右子树里。如果哈希值相等，HashMap希望key值最好是实现了Comparable接口的，这样它可以按照顺序来进行插入。<br>ConcurrentHashMap (锁分段机制)，concurrentLevel,<strong>jdk1.8采用CAS算法(无锁算法，不再使用锁分段)</strong>，<strong>数组+链表中也引入了红黑树的使用</strong><br>— default关键字<br>通常都是认为接口里面是只能有抽象方法，不能有任何方法的实现的，那么在jdk1.8里面打破了这个规定，引入了新的关键字default，通过使用default修饰方法，可以让我们在接口里面定义具体的方法实现,如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public interface NewCharacter &#123;</span><br><span class="line">    </span><br><span class="line">    public void test1();</span><br><span class="line">    </span><br><span class="line">    public default void test2()&#123;</span><br><span class="line">        System.out.println(&quot;我是新特性1&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>定义一个方法的作用是什么呢？为什么不在接口的实现类里面再去实现方法呢？<br>　　其实这么定义一个方法的主要意义是定义一个默认方法，也就是说这个接口的实现类实现了这个接口之后，不用管这个default修饰的方法，也可以直接调用，如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class NewCharacterImpl implements NewCharacter&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void test1() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        NewCharacter nca = new NewCharacterImpl();</span><br><span class="line">        nca.test2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>default方法是所有的实现类都不需要去实现的就可以直接调用，那么比如说jdk的集合List里面增加了一个sort方法，那么如果定义为一个抽象方法，其所有的实现类如arrayList,LinkedList等都需要对其添加实现，那么现在用default定义一个默认的方法之后，其实现类可以直接使用这个方法了，这样不管是开发还是维护项目，都会大大简化代码量  </p><h3 id="继承和组合"><a href="#继承和组合" class="headerlink" title="继承和组合"></a>继承和组合</h3><p>借鉴这篇文章 ：<br><a href="https://blog.csdn.net/wrs120/article/details/88584705" target="_blank" rel="noopener">https://blog.csdn.net/wrs120/article/details/88584705</a></p><h4 id="继承优点："><a href="#继承优点：" class="headerlink" title="继承优点："></a>继承优点：</h4><ul><li>代码复用</li><li>子类可重写父类方法</li><li>子类在父类的继承上可根据自己的业务需求扩展</li><li>创建子类对象时，无需创建父类对象，子类自动继承父类的的成员变量和方法，如果权限允许，子类可直接访问<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4></li><li>不支持动态继承，在编译阶段就确定了子类的父类</li><li>破坏封装性</li><li>封装性指出每个类都应该封装它内容信息和实现细节，而只暴露必要的方法给其他类使用。但在继承关系中，子类可以直接访问父类的成员变量和方法，如下例子中父类Fruit中有成员变量weight。Apple继承了Fruit之后,Apple可直接操作Fruit类的成员变量，因此破坏了封装性!</li><li>紧耦合<br>当父类的实现做了修改时，父类也不得不修改（比如修改了父类某个接口名，子类也必须作相应修改）；子类必须依赖父类存在</li></ul><h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul><li>支持动态扩展，可在运行时根据具体对象选择不同类型的组合对象(扩展性比继承好)</li><li>不破坏封装性</li><li>松耦合<h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5></li><li>整体类不能自动获取局部类的接口(整体类可      以看成是上面的bird，如果想在bird里使用Animal的方法，必须写代码来调用，但是继承，bird自动就拥有了animal的方法)</li><li>没有实现多态</li></ul><h4 id="组合举例"><a href="#组合举例" class="headerlink" title="组合举例"></a>组合举例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public class Animal &#123;</span><br><span class="line">    private void beat()&#123;</span><br><span class="line">        System.out.println(&quot;心脏跳动...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void breath()&#123;</span><br><span class="line">        beat();</span><br><span class="line">        System.out.println(&quot;呼吸中...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Bird &#123;</span><br><span class="line">    //将Animal作为Bird的成员变量</span><br><span class="line">    private Animal a;</span><br><span class="line">    public Bird(Animal a)&#123;</span><br><span class="line">        this.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    public void breath()&#123;</span><br><span class="line">        a.breath();</span><br><span class="line">    &#125;</span><br><span class="line">    public void fly()&#123;</span><br><span class="line">        System.out.println(&quot;我在飞..&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        Animal animal = new Animal();</span><br><span class="line">        Bird b = new Bird(animal);</span><br><span class="line">        b.breath();</span><br><span class="line">        b.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择?"></a>如何选择?</h4><ul><li>想实现复用，并且复用部分可能改变，用继承；复用不会改变，用组合</li><li>当两个类之间明显存在整体与部分的关系时，用组合关系</li></ul><h3 id="进程间的通讯方式"><a href="#进程间的通讯方式" class="headerlink" title="进程间的通讯方式"></a>进程间的通讯方式</h3><h4 id="liunx六大进程间通信方式"><a href="#liunx六大进程间通信方式" class="headerlink" title="liunx六大进程间通信方式"></a>liunx六大进程间通信方式</h4><h5 id="管道，消息队列，共享内存，信号量，socket，信号，文件锁"><a href="#管道，消息队列，共享内存，信号量，socket，信号，文件锁" class="headerlink" title="管道，消息队列，共享内存，信号量，socket，信号，文件锁"></a>管道，消息队列，共享内存，信号量，socket，信号，文件锁</h5><ul><li><p>1，管道</p><pre><code>1，匿名管道：           概念：在内核中申请一块固定大小的缓冲区，程序拥有写入和读取的权利，一般使用fork函数实现父子进程的通信。2，命名管道：             概念：在内核中申请一块固定大小的缓冲区，程序拥有写入和读取的权利，没有血缘关系的进程也可以进程间通信。3，特点：          1，面向字节流，          2，生命周期随内核          3，自带同步互斥机制。          4，半双工，单向通信，两个管道实现双向通信。  </code></pre></li><li>2，消息队列<br> 1，概念：在内核中创建一队列，队列中每个元素是一个数据报，不同的进程可以通过句柄去访问这个队列。<pre><code>           消息队列提供了⼀个从⼀个进程向另外⼀ 个进程发送⼀块数据的⽅法。            每个数据块都被认为是有⼀个类型，接收者进程接收的数据块可以有不同的类型值                                                                 消息队列也有管道⼀样的不⾜，就是每个消息的最⼤⻓度是有上限的（MSGMAX），            每个消息队 列的总的字节数是有上限的（MSGMNB），系统上消息队列的总数也有⼀个上限（MSGMNI）  </code></pre>  2，特点：<pre><code>        1， 消息队列可以认为是一个全局的一个链表，链表节点钟存放着数据报的类型和内容，有消息队列的标识符进行标记。        2，消息队列允许一个或多个进程写入或者读取消息。        3，消息队列的生命周期随内核。        4，消息队列可实现双向通信。</code></pre></li><li><p>3，信号量     </p><pre><code>  1，概念                在内核中创建一个信号量集合（本质是个数组），数组的元素（信号量）都是1，使用P操作进行-1，使用V操作+1，                （1） P(sv)：如果sv的值⼤大于零，就给它减1；如果它的值为零，就挂起该进程的执⾏ 。                （2） V(sv)：如果有其他进程因等待sv而被挂起，就让它恢复运⾏，如果没有进程因等待sv⽽挂起，就给它加1。                     PV操作用于同一进程，实现互斥。                    PV操作用于不同进程，实现同步。   2，功能：               对临界资源进行保护。       </code></pre></li><li>4，共享内存      <pre><code> 1，概念：            将同一块物理内存一块映射到不同的进程的虚拟地址空间中，实现不同进程间对同一资源的共享。            共享内存可以说是最有用的进程间通信方式，也是最快的IPC形式。  2，特点：           1，不用从用户态到内核态的频繁切换和拷贝数据，直接从内存中读取就可以。           2，共享内存是临界资源，所以需要操作时必须要保证原子性。使用信号量或者互斥锁都可以。           3，生命周期随内核。     </code></pre></li><li>5，总结<pre><code>  所有的以上的方式都是生命周期随内核，不手动释就不会消失。</code></pre></li></ul><h3 id="为什么java不提供指针访问内存就会内存更安全"><a href="#为什么java不提供指针访问内存就会内存更安全" class="headerlink" title="为什么java不提供指针访问内存就会内存更安全"></a>为什么java不提供指针访问内存就会内存更安全</h3><p><a href="https://bbs.csdn.net/topics/50223289" target="_blank" rel="noopener">https://bbs.csdn.net/topics/50223289</a><br>java的设计思想就是“安全第一”，将大部分工作转移到堆上，严格限制指针的使用（甚至连指针这个名字都不用）。但是java中还是有指针的，当我们创建一个对象实例时，也就同时声明了一个指向该实例的堆存储空间入口地址的指针，这个指针也称为“引用”。引用可以指向其他相关类型的实例存储空间，但是<strong>只能指向这些存储空间的入口地址</strong>，<strong>不能任意指向其中的存储区域</strong>；再配合GC，<strong>提供了很好的安全性。Java实际上就是将管理内存的指针操作都封装在jvm中</strong>，让程序员能够更多地关注于方案的设计和优化。  </p><h3 id="构造器-Constructor-是否可被-override"><a href="#构造器-Constructor-是否可被-override" class="headerlink" title="构造器 Constructor 是否可被 override?"></a>构造器 Constructor 是否可被 override?</h3><p>在讲继承的时候我们就知道父类的私有属性和<strong>构造方法并不能被继承</strong>，所以 Constructor 也就<strong>不能被 override（重写）,但是可以 overload（重载）</strong>,所以你可以看到一个类中有多个构造函数的情况。  </p><h3 id="10-重载和重写的区别"><a href="#10-重载和重写的区别" class="headerlink" title="10. 重载和重写的区别"></a>10. 重载和重写的区别</h3><ul><li>重载： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 　　</li><li>重写： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。   </li></ul><h3 id="关于继承如下-3-点请记住："><a href="#关于继承如下-3-点请记住：" class="headerlink" title="关于继承如下 3 点请记住："></a>关于继承如下 3 点请记住：</h3><p>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，只是拥有。<br>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。<br>子类可以用自己的方式实现父类的方法。（以后介绍）。    </p><h3 id="18-成员变量与局部变量的区别有那些？"><a href="#18-成员变量与局部变量的区别有那些？" class="headerlink" title="18. 成员变量与局部变量的区别有那些？"></a>18. 成员变量与局部变量的区别有那些？</h3><p>从语法形式上看:成员变量是属于类的，而局部变量是在方法中定义的变量  或是方法的参数；成员变量可以被 public,private,static 等修饰符   所修饰，而<strong>局部变量不能被访问控制修饰符及 static 所修饰</strong>；但是，成员变量和局部变量都能被 final 所修饰。<br>从变量在内存中的存储方式来看:如果成员变量是使用static修饰的，那么  这个成员变量是属于类的，如果没有使用static修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。<br>从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。<br>成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而<strong>局部变量则不会自动赋值</strong>。    </p><h3 id="在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是"><a href="#在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是" class="headerlink" title="在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?"></a>在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?</h3><p>帮助子类做初始化工作    </p><h3 id="总结一下Java中方法参数的使用情况："><a href="#总结一下Java中方法参数的使用情况：" class="headerlink" title="总结一下Java中方法参数的使用情况："></a>总结一下Java中方法参数的使用情况：</h3><ul><li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li><li>一个方法可以改变一个对象参数的状态。</li><li>一个方法不能让对象参数引用一个新的对象。  (对象引用做参数实际上是对引用做了一份拷贝，所以可以相应改变对象的状态，但是却没法让对象参数引用一个新的对象)  <h3 id="Java异常类层次结构图"><a href="#Java异常类层次结构图" class="headerlink" title="Java异常类层次结构图"></a>Java异常类层次结构图</h3><img src="https://my-blog-to-use.oss-cn-beijing.aliyuncs.com/2019-2/Exception.png" alt="Java异常类层次结构图"> </li></ul><h4 id="异常处理总结"><a href="#异常处理总结" class="headerlink" title="异常处理总结"></a>异常处理总结</h4><ul><li>try 块：用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则<strong>必须跟一个finally块</strong>。</li><li>catch 块：用于处理try捕获到的异常。</li><li>finally 块：无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中<strong>遇到return语句时，finally语句块将在方法返回之前被执行</strong>。  <h3 id="在以下4种特殊情况下，finally块不会被执行："><a href="#在以下4种特殊情况下，finally块不会被执行：" class="headerlink" title="在以下4种特殊情况下，finally块不会被执行："></a>在以下4种特殊情况下，finally块不会被执行：</h3></li><li>在finally语句块第一行发生了异常。 因为在其他行，finally块还是会得到执行</li><li>在前面的代码中用了System.exit(int)已退出程序。 exit是带参函数 ；若该语句在异常语句之后，finally会执行</li><li>程序所在的线程死亡。</li><li>关闭CPU。  </li></ul><h3 id="static-关键字"><a href="#static-关键字" class="headerlink" title="static 关键字"></a>static 关键字</h3><p>static 关键字主要有以下四种使用场景：  </p><ul><li>修饰成员变量和成员方法: 被 static 修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以并且建议通过类名调用。被static 声明的成员变量属于静态成员变量，静态变量 存放在 Java 内存区域的方法区。调用格式：类名.静态变量名 类名.静态方法名()</li><li>静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—&gt;非静态代码块—&gt;构造方法)。 该类不管创建多少对象，静态代码块只执行一次.</li><li>静态内部类（static修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用就意味着：1. 它的创建是不需要依赖外围类的创建。2. 它不能使用任何外围类的非static成员变量和方法。</li><li>静态导包(用来导入类中的静态资源，1.5之后的): 格式为：import static 这两个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。    </li></ul><h3 id="所有整形包装类对象值的比较必须使用equals方法。"><a href="#所有整形包装类对象值的比较必须使用equals方法。" class="headerlink" title="所有整形包装类对象值的比较必须使用equals方法。"></a>所有整形包装类对象值的比较必须使用equals方法。</h3><p>先看下面这个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer x = 3;  </span><br><span class="line">Integer y = 3;</span><br><span class="line">System.out.println(x == y);// true</span><br><span class="line">Integer a = new Integer(3);</span><br><span class="line">Integer b = new Integer(3);</span><br><span class="line">System.out.println(a == b);//false</span><br><span class="line">System.out.println(a.equals(b));//false</span><br></pre></td></tr></table></figure></p><p>当使用自动装箱方式创建一个Integer对象时，当数值在-128 ~127时，会将创建的Integer对象缓存起来，当下次再出现该数值时，直接从缓存中取出对应的Integer对象。所以上述代码中，x和y引用的是相同的Integer对象。  </p><h3 id="get和post请求的区别"><a href="#get和post请求的区别" class="headerlink" title="get和post请求的区别"></a>get和post请求的区别</h3><p>网上也有文章说：get和post请求实际上是没有区别，大家可以自行查询相关文章（参考文章：<a href="https://www.cnblogs.com/logsharing/p/8448446.html，知乎对应的问题链接：get和post区别？）！我下面给出的只是一种常见的答案。" target="_blank" rel="noopener">https://www.cnblogs.com/logsharing/p/8448446.html，知乎对应的问题链接：get和post区别？）！我下面给出的只是一种常见的答案。</a></p><ul><li><p>①get请求用来从服务器上获得资源，而post是用来向服务器提交数据；</p></li><li><p>②get将表单中数据按照name=value的形式，添加到action 所指向的URL 后面，并且两者使用”?”连接，而各个变量之间使用”&amp;”连接；post是将表单中的数据放在HTTP协议的请求头或消息体中，传递到action所指向URL；</p></li><li><p>③get传输的数据要受到URL长度限制（最大长度是 2048 个字符）；而post可以传输大量的数据，上传文件通常要使用post方式；</p></li><li><p>④使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post；</p></li><li><p>⑤get使用MIME类型application/x-www-form-urlencoded的URL编码（也叫百分号编码）文本的格式传递参数，保证被传送的参数由遵循规范的文本组成，例如一个空格的编码是”%20”。</p></li></ul><p>补充：GET方式提交表单的典型应用是搜索引擎。GET方式就是被设计为查询用的。</p><h4 id="对于GET方式的请求，浏览器会把http-header和data一并发送出去，服务器响应200（返回数据）；"><a href="#对于GET方式的请求，浏览器会把http-header和data一并发送出去，服务器响应200（返回数据）；" class="headerlink" title="对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；"></a>对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；</h4><h4 id="而对于POST，浏览器先发送header，服务器响应100-continue，浏览器再发送data，服务器响应200-ok（返回数据）。"><a href="#而对于POST，浏览器先发送header，服务器响应100-continue，浏览器再发送data，服务器响应200-ok（返回数据）。" class="headerlink" title="而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。"></a>而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。</h4><ul><li>也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。<h3 id="转发-Forward-和重定向-Redirect-的区别"><a href="#转发-Forward-和重定向-Redirect-的区别" class="headerlink" title="转发(Forward)和重定向(Redirect)的区别"></a>转发(Forward)和重定向(Redirect)的区别</h3></li><li><p>转发是服务器行为，重定向是客户端行为。</p></li><li><p>转发（Forward） 通过RequestDispatcher对象的forward（HttpServletRequest request,HttpServletResponse response）方法实现的。RequestDispatcher可以通过HttpServletRequest 的getRequestDispatcher()方法获得。例如下面的代码就是跳转到login_success.jsp页面。</p><p>   request.getRequestDispatcher(“login_success.jsp”).forward(request, response);</p></li><li><p>重定向（Redirect） 是利用服务器返回的状态码来实现的。客户端浏览器请求服务器的时候，服务器会返回一个状态码。服务器通过 HttpServletResponse 的 setStatus(int status) 方法设置状态码。如果服务器返回301或者302，则浏览器会到新的网址重新请求该资源。</p></li><li><p>从地址栏显示来说<br>forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址. redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.</p></li><li><p>从数据共享来说<br>forward:转发页面和转发到的页面可以共享request里面的数据. redirect:不能共享数据.</p></li><li><p>从运用地方来说<br>forward:一般用于用户登陆的时候,根据角色转发到相应的模块. redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等</p></li><li><p>从效率来说<br>forward:高. redirect:低.</p></li></ul><h3 id="关于java的对象和集合长度注意"><a href="#关于java的对象和集合长度注意" class="headerlink" title="关于java的对象和集合长度注意"></a>关于java的对象和集合长度注意</h3><ul><li>java 中的 length 属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li><li>java 中的 length() 方法是针对字符串说的,如果想看这个字符串的长度则用到 length() 这个方法.</li><li>java 中的 size() 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li></ul><h3 id="LinkedHashMap-结构图（hashmap结构基础上增加了双向链表）"><a href="#LinkedHashMap-结构图（hashmap结构基础上增加了双向链表）" class="headerlink" title="LinkedHashMap 结构图（hashmap结构基础上增加了双向链表）"></a>LinkedHashMap 结构图（hashmap结构基础上增加了双向链表）</h3><p><img src="https://blog-pictures.oss-cn-shanghai.aliyuncs.com/15166338955699.jpg" alt="LinkedHashMap">    </p><h3 id="4-1-为什么要用线程池？"><a href="#4-1-为什么要用线程池？" class="headerlink" title="4.1. 为什么要用线程池？"></a>4.1. 为什么要用线程池？</h3><p>线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。  </p><ul><li><p>降低资源消耗。 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。  </p></li><li><p>提高响应速度。 当任务到达时，任务可以不需要的等到线程创建就能立即执行。</p></li><li>提高线程的可管理性。 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。  </li></ul><h3 id="java的自动拆装箱"><a href="#java的自动拆装箱" class="headerlink" title="java的自动拆装箱"></a>java的自动拆装箱</h3><p><a href="https://www.cnblogs.com/kitor/p/10469276.html" target="_blank" rel="noopener">转载：</a> </p><h4 id="案例引入："><a href="#案例引入：" class="headerlink" title="案例引入："></a>案例引入：</h4><pre><code>public static void main(String[] args) {Integer i = 10;Integer j = 10;System.out.println(i == j);Integer a = 128;Integer b = 128;System.out.println(a == b);int k = 10;System.out.println(k == i);int kk = 128;System.out.println(kk == a);Integer m = new Integer(10);Integer n = new Integer(10);System.out.println(m == n);}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">执行结果：</span><br></pre></td></tr></table></figure><pre><code>    true    false    true    true    false</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure><p>Java中的语法糖也是新增了一些语法，使得程序员使用更加方便。但是计算机底层还是使用基本语法来实现的。下面我们讨论几个经常使用到的语法糖，可变参数、自动装箱/拆箱、增强for循环。</p><p>我们以Integer类为例，在我们用如下代码编写程序后，当使用Javac.exe工具操作之后，编译器会把我们的这个程序重写按照DRY（Don’t repeat yourself）原则进行编译  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Integer num1 = 123;//将一个基本数据类型赋给Integer对象</span><br><span class="line">        int num2 = num1;//将一个Integer对象赋给整形变量</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">对以上代码编译后的Test.class反编译结果如下</span><br></pre></td></tr></table></figure><pre><code>public class Test{      public static void main(String[] args) {        Integer num1 = Integer.valueOf(123);//装箱操作           int num2 = num1.intValue();//拆箱操作      }}</code></pre><p>```          </p><ul><li><p>结果分析<br>了解了上面代码的转换过程，我们从反编译的结果得知：再Java语言中永远遵守不同类型之间不可以进行赋值的规则。置于我们在代码中的编写形式有时只是进行了简写，而最后的执行还要依赖于编译器的解析结果。</p></li><li><p>实现过程<br>上方就是基本数据类型的自动拆/装箱，他们的装箱遵循以下规则</p></li></ul><p>自动装箱规范要求 byte&lt;= 127、char&lt;=127、-128&lt;=short &lt;=127、-128&lt;=int &lt;=127都被包装到固定的对象中（缓存）。</p><p>也就是说在装箱过程中执行valueOf(参数)方法后，如果满足以上条件就会被封装成Integer对象中。valueOf函数如下:<br><img src="https://img2018.cnblogs.com/blog/1500954/201903/1500954-20190304115238909-1677329599.png" alt><br>从函数可以看出，当在-128到127范围内，会生成同一个对象，在范围之外，会执行new Integer（）；我们都知道在Java语言中，new一个对象是存储在堆里的，我们通过栈中的引用来使用这些对象；所以，对象本身来说是比较消耗资源的。  </p><ul><li>总结<br>包装类的应用</li></ul><p>1、Java中的集合类只能接收对象类型，而Java通过包装类实现了把基本数据类型放入集合操作的目的。并且在放入集合的时候这种封装时自动完成的。</p><p>2、包装类与基本数据类型进行比较运算，是先将包装类进行拆箱成基本数据类型，然后进行比较的。</p><p>3、两个包装类型之间的运算，会被自动拆箱成基本类型进行。</p><p>4、三目运算符flag ? i : j;片段中，三目运算符的语法规范：当第二，第三位操作数分别为基本类型和对象时，其中的对象就会拆箱为基本类型进行操作。如果这个时候i的值为null，那么久会发生NPE。（自动拆箱导致空指针异常）</p><p>5、函数参数与返回值</p><p>6、Integer中的缓存机制有关。在Java 5中，在Integer的操作上引入了一个新功能来节省内存和提高性能。整型对象通过使用相同的对象引用实现了缓存和重用。适用于整数值区间-128 至 +127。只适用于自动装箱。使用<strong>构造函数创建对象不适用</strong>。当需要进行自动装箱时，如果数字在-128至127之间时，会直接使用缓存中的对象，而不是重新创建一个对象。</p><p>另外javadoc详细的说明了缓存支持-128到127之间的自动装箱过程。最大值127可以通过-XX:AutoBoxCacheMax=size修改。实际上这个功能在Java 5中引入的时候,范围是固定的-128 至 +127。后来在Java 6中，可以通过java.lang.Integer.IntegerCache.high设置最大值。    </p><ul><li>注意事项<br>包装类的使用简化了代码，方便了编程者对数据的操作，实现了面向对象思想，但是也引入了一些麻烦，我们要尽量避免，以防对以后的编程中出现负担。</li></ul><p>1、包装对象的数值比较，不能简单的使用==，虽然-128到127之间的数字可以，但是这个范围之外还是需要使用equals比较。</p><p>2、如果一个for循环中有大量拆装箱操作，会浪费很多资源。</p><p>3、有些场景会进行自动拆装箱，同时也说过，由于自动拆箱，如果包装类对象为null，那么自动拆箱时就有可能抛出NPE。</p><h3 id="hashmap"><a href="#hashmap" class="headerlink" title="hashmap"></a>hashmap</h3><ul><li>hashmap是一个key-value键值对的数据结构，从结构上来讲在jdk1.8之前是用数组加链表的方式实现，jdk1.8加了红黑树，hashmap数组的默认初始长度是16，hashmap数组只允许一个key为null，允许多个value为null</li><li><strong>hashmap的内部实现</strong>，hashmap是使用数组+链表+红黑树的形式实现的，其中数组是一个一个Node[]数组，我们叫他hash桶数组，它上面存放的是key-value键值对的节点。HashMap是用hash表来存储的，在hashmap里为解决hash冲突，使用链地址法，简单来说就是数组加链表的形式来解决，当数据被hash后，得到数组下标，把数据放在对应下表的链表中。</li><li>然后再说一下hashmap的方法实现</li><li><strong>put方法</strong>，put方法的第一步，就是计算出要put元素在hash桶数组中的索引位置，得到索引位置需要三步，去put元素key的hashcode值，高位运算，取模运算，高位运算就是用第一步得到的值h，用h的高16位和低16位进行异或操作，第三步为了使hash桶数组元素分布更均匀，采用取模运算，取模运算就是用第二步得到的值和hash桶数组长度-1的值取与。这样得到的结果和传统取模运算结果一致，而且效率比取模运算高<br>jdk1.8中put方法的具体步骤，首先判断key是否为null，若为null，则直接调用putForNullKey方法。先判断hashmap是否为空，为空的话扩容，不为空计算出key的hash值i，然后看table[i]是否为空，为空就直接插入，不为空判断当前位置的key和table[i]是否相同，相同就覆盖，不相同就查看table[i]是否是红黑树节点，如果是的话就用红黑树直接插入键值对，如果不是开始遍历链表插入，如果遇到重复值就覆盖，否则直接插入，如果链表长度大于8，转为红黑树结构，执行完成后看size是否大于阈值threshold，大于就扩容，否则直接结束  </li></ul><pre><code>    public V put(K key, V value) {    //当key为null，调用putForNullKey方法，保存null与table第一个位置中，这是HashMap允许为null的原因    if (key == null)        return putForNullKey(value);    //计算key的hash值    int hash = hash(key.hashCode());                  ------(1)    //计算key hash值在table数组中的位置    int i = indexFor(hash, table.length);             ------(2)    //从i出开始迭代e,找到key保存的位置    for (Entry&lt;K, V&gt; e = table[i]; e != null; e = e.next) {        Object k;        //判断该条链上是否有hash值相同的(key相同)        //若存在相同，则直接覆盖value，返回旧value        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) {            V oldValue = e.value;    //旧值=新值            e.value = value;            e.recordAccess(this);            return oldValue;     //返回旧值        }    }    //修改次数增加1    modCount++;    //将key、value添加至i位置处    addEntry(hash, key, value, i);    return null;}    //当key为null，调用putForNullKey方法，保存null与table第一个位置中，这是HashMap允许为null的原因    if (key == null)        return putForNullKey(value);  </code></pre><ul><li>get方法就是计算出要获取元素的hash值，去对应位置取即可。</li><li><strong>扩容机制</strong>，hashmap的扩容中主要进行两部，<ul><li>第一步把数组长度变为原来的两倍  </li><li>第二部把旧数组的元素重新计算hash插入到新数组中，在jdk1.8时，不用重新计算hash，只用看看原来的hash值新增的一位是零还是1，如果是1这个元素在新数组中的位置，是原数组的位置加原数组长度，如果是零就插入到原数组中(检测元素的hash值与原数组长度作与操作的结果是否为0：为0，那么下标还是原来的下标；为1，那么下标等于原来下标加上旧数组长度。)，并且把transfer方法放在了resize()里边实现。扩容过程第二部一个非常重要的方法是transfer方法，采用头插法，把旧数组的元素插入到新数组中。<br>数组长度：2，key：3<br>0 0 0 1<br>0 0 1 1 结果为 0 0 0 1 = 1 所以数组下标为1；</li></ul></li></ul><p>扩容后，数组长度：4，key：3<br>0 0 1 1<br>0 0 1 1 结果为 0 0 1 1 = 3 = 原来的index + oldCap = 1 + 2</p><p>确定元素在新数组的下标时，我们只需要检测元素的hash值与oldCap作与操作的结果是否为0：为0，那么下标还是原来的下标；为1，那么下标等于原来下标加上旧数组长度。  </p><ul><li>hashmap大小为什么是2的幂次方<br>在计算插入元素在hash桶数组的索引时第三步，为了使元素分布的更加均匀，用取模操作，但是传统取模操作效率低，然后优化成h&amp;(length-1)，设置成2幂次方，是因为2的幂次方-1后的值每一位上都是1，然后与第二步计算出的h值与的时候，最终的结果只和key的hashcode值本身有关，这样不会造成空间浪费并且分布均匀，如果不是2的幂次方<br>如果length不为2的幂，比如15。那么length-1的2进制就会变成1110。在h为随机数的情况下，和1110做&amp;操作。尾数永远为0。那么0001、1001、1101等尾数为1的位置就永远不可能被entry占用。这样会造成浪费，不随机等问题。    <h4 id="如果事先能估算出容器所要存储的元素数量，最好在初始化时修改默认容量capacity，以防止频繁的resize操作影响性能。"><a href="#如果事先能估算出容器所要存储的元素数量，最好在初始化时修改默认容量capacity，以防止频繁的resize操作影响性能。" class="headerlink" title="如果事先能估算出容器所要存储的元素数量，最好在初始化时修改默认容量capacity，以防止频繁的resize操作影响性能。"></a>如果事先能估算出容器所要存储的元素数量，最好在初始化时修改默认容量capacity，以防止频繁的resize操作影响性能。</h4></li></ul><h3 id="yield-和sleep区别"><a href="#yield-和sleep区别" class="headerlink" title="yield  和sleep区别"></a>yield  和sleep区别</h3><p>yield()没有参数</p><pre><code>sleep 方法使当前运行中的线程睡眠一段时间，进入不可以运行状态，这段时间的长短是由程序设定的，yield方法使当前线程让出CPU占有权，但让出的时间是不可设定的。yield()也不会释放锁标志。实际上，yield()方法对应了如下操作；先检测当前是否有相同优先级的线程处于同可运行状态，如有，则把CPU的占有权交给次线程，否则继续运行原来的线程，所以yield()方法称为**“退让”**，它把运行机会让给了同等级的其他线程。sleep 方法允许较低优先级的线程获得运行机会，但yield（）方法执行时，当前线程仍处在可运行状态，所以不可能让出较低优先级的线程此时获取CPU占有权。在一个运行系统中，如果较高优先级的线程没有调用sleep方法，也没有受到I/O阻塞，那么较低优先级线程只能等待所有较高优先级的线程运行结束，方可有机会运行。yield()只是使当前线程重新回到可执行状态，所有执行yield()的线程有可能在进入到可执行状态后马上又被执行，所以yield()方法只能使同优先级的线程有执行的机会。</code></pre><h3 id="面向对象基本原则"><a href="#面向对象基本原则" class="headerlink" title="面向对象基本原则"></a>面向对象基本原则</h3><ul><li><ol><li>单一职责原则（Single Responsibility Principle）</li></ol></li></ul><p>每一个类应该专注于做一件事情。</p><ul><li><ol><li>里氏替换原则（Liskov Substitution Principle）</li></ol></li></ul><p>超类存在的地方，子类是可以替换的。</p><ul><li><ol><li>依赖倒置原则（Dependence Inversion Principle）</li></ol></li></ul><p>实现尽量依赖抽象，不依赖具体实现。</p><ul><li><ol><li>接口隔离原则（Interface Segregation Principle）</li></ol></li></ul><p>应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。</p><ul><li><ol><li>迪米特法则（Law Of Demeter）</li></ol></li></ul><p>又叫最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用。</p><ul><li><ol><li>开闭原则（Open Close Principle）</li></ol></li></ul><p>面向扩展开放，面向修改关闭。</p><ul><li><ol><li>组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）</li></ol></li></ul><p>尽量使用合成/聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象。   </p><h4 id="细则"><a href="#细则" class="headerlink" title="细则"></a>细则</h4><ul><li>单一职责原则（Single Responsibility Principle）</li></ul><p>因为：</p><p>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；提高类的可读性，提高系统的可维护性；变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。</p><p>所以：</p><p>从大局上看Android中的Paint和Canvas等类都遵守单一职责原则，Paint和Canvas各司其职。</p><ul><li>里氏替换原则（Liskov Substitution Principle）</li></ul><p>因为：</p><p>里氏替换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。里氏替换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p><p>所以：</p><p>使用里氏替换原则时需要注意，子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。</p><p>从大局看Java的多态就属于这个原则。</p><ul><li>依赖倒置原则（Dependence Inversion Principle）</li></ul><p>因为：</p><p>具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类；而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口；这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能造成循环依赖。</p><p>所以：</p><p>采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，减少并行开发引起的风险，提高代码的可读性和可维护性。</p><p>从大局看Java的多态就属于这个原则。</p><ul><li>接口隔离原则（Interface Segregation Principle）</li></ul><p>因为：</p><p>提供尽可能小的单独接口，而不要提供大的总接口。暴露行为让后面的实现类知道的越少越好。譬如类ProgramMonkey通过接口CodeInterface依赖类CodeC，类ProgramMaster通过接口CodeInterface依赖类CodeAndroid，如果接口CodeInterface对于类ProgramMonkey和类CodeC来说不是最小接口，则类CodeC和类CodeAndroid必须去实现他们不需要的方法。将臃肿的接口CodeInterface拆分为独立的几个接口，类ProgramMonkey和类ProgramMaster分别与他们需要的接口建立依赖关系。也就是采用接口隔离原则。</p><p>所以：</p><p>建立单一接口，不要建立庞大的接口，尽量细化接口，接口中的方法尽量少。也就是要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的约定，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p><p>从大局来说Java的接口可以实现多继承就是接口隔离原则的基础保障。</p><ul><li>迪米特法则（Law Of Demeter）</li></ul><p>因为：</p><p>类与类之间的关系越密切，耦合度也就越来越大，只有尽量降低类与类之间的耦合才符合设计模式；对于被依赖的类来说，无论逻辑多复杂都要尽量封装在类的内部；每个对象都会与其他对象有耦合关系，我们称出现成员变量、方法参数、方法返回值中的类为直接的耦合依赖，而出现在局部变量中的类则不是直接耦合依赖，也就是说，不是直接耦合依赖的类最好不要作为局部变量的形式出现在类的内部。</p><p>所以：</p><p>一个对象对另一个对象知道的越少越好，即一个软件实体应当尽可能少的与其他实体发生相互作用，在一个类里能少用多少其他类就少用多少，尤其是局部变量的依赖类，能省略尽量省略。同时如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一方法的话，可以通过第三者转发这个调用。</p><p>从大局来说Android App开发中的多Fragment与依赖的Activity间交互通信遵守了这一法则。</p><ul><li>开闭原则（Open Close Principle）</li></ul><p>因为：</p><p>开放封闭原则主要体现在对扩展开放、对修改封闭，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。软件需求总是变化的，世界上没有一个软件的是不变的，因此对软件设计人员来说，必须在不需要对原有系统进行修改的情况下，实现灵活的系统扩展。</p><p>所以：</p><p>可以通过Template Method模式和Strategy模式进行重构，实现对修改封闭，对扩展开放的设计思路。<br>封装变化，是实现开放封闭原则的重要手段，对于经常发生变化的状态，一般将其封装为一个抽象，拒绝滥用抽象，只将经常变化的部分进行抽象。</p><ul><li>组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）</li></ul><p>因为：</p><p>其实整个设计模式就是在讲如何类与类之间的组合/聚合。在一个新的对象里面通过关联关系（包括组合关系和聚合关系）使用一些已有的对象，使之成为新对象的一部分，新对象通过委派调用已有对象的方法达到复用其已有功能的目的。也就是，要尽量使用类的合成复用，尽量不要使用继承。</p><p>如果为了复用，便使用继承的方式将两个不相干的类联系在一起，违反里氏代换原则，哪是生搬硬套，忽略了继承了缺点。继承复用破坏数据封装性，将基类的实现细节全部暴露给了派生类，基类的内部细节常常对派生类是透明的，白箱复用；虽然简单，但不安全，不能在程序的运行过程中随便改变；基类的实现发生了改变，派生类的实现也不得不改变；从基类继承而来的派生类是静态的，不可能在运行时间内发生改变，因此没有足够的灵活性。</p><p>所以：</p><p>组合/聚合复用原则可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合/聚合来实现复用；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。  </p><h3 id="如何正确使用线程池"><a href="#如何正确使用线程池" class="headerlink" title="如何正确使用线程池"></a>如何正确使用线程池</h3><p><a href="https://www.cnblogs.com/CarpenterLee/p/9558026.html" target="_blank" rel="noopener">https://www.cnblogs.com/CarpenterLee/p/9558026.html</a><br>避免使用无界队列<br>不要使用Executors.newXXXThreadPool()快捷方法创建线程池，因为这种方式会使用无界的任务队列，为避免OOM，我们应该使用ThreadPoolExecutor的构造方法手动指定队列的最大长度：</p><pre><code>ExecutorService executorService = new ThreadPoolExecutor(2, 2,                 0, TimeUnit.SECONDS,                 new ArrayBlockingQueue&lt;&gt;(512), // 使用有界队列，避免OOM                new ThreadPoolExecutor.DiscardPolicy());   </code></pre><p>Executors中创建线程池的快捷方法，实际上是调用了ThreadPoolExecutor的构造方法（定时任务使用的是ScheduledThreadPoolExecutor），该类构造方法参数列表如下：</p><pre><code>// Java线程池的完整构造函数public ThreadPoolExecutor(  int corePoolSize, // 线程池长期维持的线程数，即使线程处于Idle状态，也不会回收。  int maximumPoolSize, // 线程数的上限  long keepAliveTime, TimeUnit unit, // 超过corePoolSize的线程的idle时长，                                     // 超过这个时间，多余的线程会被回收。  BlockingQueue&lt;Runnable&gt; workQueue, // 任务的排队队列  ThreadFactory threadFactory, // 新线程的产生方式  RejectedExecutionHandler handler) // 拒绝策略  </code></pre><h3 id="关于null"><a href="#关于null" class="headerlink" title="关于null"></a>关于null</h3><p><a href="https://blog.csdn.net/qq_25077777/article/details/80174763" target="_blank" rel="noopener">java中的null类型—-有关null的9件事</a></p><p> 因为null类型没有名字，所以不可能声明为null类型的变量或者转换为null类型。</p><pre><code>        null引用是null类型表达式唯一可能的值。        null引用可以转换为任意引用类型。        实际上，程序员可以忽略null类型，可以认为null仅仅是一个可以称为任何引用类型的特殊符号。        一个null类型(null(空)引用是这种类型的唯一的一个值)，可以赋值给任意类型，将返回一个该类型对象的空引用(其实还是null)。</code></pre><h4 id="关于null的9件事"><a href="#关于null的9件事" class="headerlink" title="关于null的9件事"></a>关于null的9件事</h4><ul><li>1）首先，null是java中的关键字，像public、static、final。它是大小写敏感的  </li><li>2）     就像每种原始类型都有默认值一样，int默认值为0，boolean的默认值为false，null是任何引用类型的默认值，不严格的说是所有object类型的默认值。就像你创建了一个布尔类型的变量，它将false作为自己的默认值，java中的任何引用变量都将null作为默认值。这对所有变量都是适用的，如成员变量、局部变量、实例变量、静态变量(但当你使用一个没有初始化的局部变量，编译器会警告你)。<br><img src="https://img-blog.csdn.net/20180503184702562?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MDc3Nzc3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt><br>这对静态和非静态的object来说都是正确的。就像你在这里看到的这样，myObj定义为静态引用，所以可以在主方法里直接使用它。<strong>注意：主方法是静态方法，不可使用非静态变量。</strong> </li><li><p>3）     要澄清一些误解，null既不是对象也不是一种类型，它仅是一种特殊的值，你可以将其赋予任何引用类型，你也可以将null转化成任何类型  </p></li><li><p>4）    null可以赋值给引用变量，<strong>不能将null赋值给基本类型变量，如int、double、float、boolean。 </strong><br><img src="https://img-blog.csdn.net/20180503185646347?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MDc3Nzc3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt><br><img src="https://img-blog.csdn.net/20180503185757305?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MDc3Nzc3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>  </p></li><li><p>5）    任何含有null值的包装类在java拆箱生成基本数据类型时候都会抛出一个空指针异常。  </p></li><li><p>6）     如果使用了带有null值的引用类型的变量，instanceof操作会返回false<br><img src="https://img-blog.csdn.net/20180503191057973?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MDc3Nzc3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>  </p></li><li>7）    可以使用静态方法来使用一个值为null的引用类型变量。因为静态方法使用静态类型绑定，不会抛空指针异常<br><img src="https://img-blog.csdn.net/20180503191921843?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1MDc3Nzc3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt>  </li><li>8）        可以将null传递给方法使用，这时方法可以接收任何引用类型，如 public void print(Object obj) 可以这样调用print(null).编译可以通过，但结果就取决去你的方法了。这个例子中的print方法，不会抛出空指针异常，只是退出，业务逻辑允许的话，推荐使用null安全的方法。  <h4 id="还有一个问题，当用System-out-println-打印一个对象时，不是要调用对象的toString-方法吗？但是打印时并没有报错，这什么原因呢？"><a href="#还有一个问题，当用System-out-println-打印一个对象时，不是要调用对象的toString-方法吗？但是打印时并没有报错，这什么原因呢？" class="headerlink" title="还有一个问题，当用System.out.println()打印一个对象时，不是要调用对象的toString()方法吗？但是打印时并没有报错，这什么原因呢？"></a>还有一个问题，当用System.out.println()打印一个对象时，不是要调用对象的toString()方法吗？但是打印时并没有报错，这什么原因呢？</h4></li></ul><p>查看println()源码：  </p><pre><code>    public void println(Object x) {    String s = String.valueOf(x);    synchronized (this) {        print(s);        newLine();    }}  </code></pre><p>方法首先把对象转化为字符串，查看valueOf()源码： </p><pre><code>public static String valueOf(Object obj) {return (obj == null) ? &quot;null&quot; : obj.toString();}</code></pre><p>可以看到，把对象转化为字符串的过程是，先把对象和null比较，如果为真，直接返回“null”,如果为假，也就是说对象不是null，再调用toString方法。这就是打印null对象不报错的原因。<br>我们顺便看看print()的源码：  </p><pre><code>    public void print(String s) {if (s == null) {    s = &quot;null&quot;;}write(s);}  </code></pre><p>可见，print()只是用来打印字符串对象的，而且针对null字符串也有特别处理。  </p><ul><li>9)    可以使用== 或者 != 操作来比较null值，但是不能使用其他算法或者逻辑操作，如大于、小于。与SQL不同，java中的null==null会返回true；  </li></ul><h3 id="为什么HashMap非线程安全"><a href="#为什么HashMap非线程安全" class="headerlink" title="为什么HashMap非线程安全"></a>为什么HashMap非线程安全</h3><p><a href="https://blog.csdn.net/wufaliang003/article/details/80219296" target="_blank" rel="noopener">为什么HashMap非线程安全</a><br>rehash方法会在链表中造成循环引用，形成链表环  </p><h3 id="雪崩效应"><a href="#雪崩效应" class="headerlink" title="雪崩效应"></a><a href="https://www.cnblogs.com/toov5/p/9895929.html" target="_blank" rel="noopener">雪崩效应</a></h3><h3 id="volatile-sychronized底层原理"><a href="#volatile-sychronized底层原理" class="headerlink" title="volatile,sychronized底层原理"></a><a href="https://www.cnblogs.com/yuxiang1/p/11310575.html" target="_blank" rel="noopener">volatile,sychronized底层原理</a></h3><p><a href="https://www.cnblogs.com/yuxiang1/p/11305546.html" target="_blank" rel="noopener">https://www.cnblogs.com/yuxiang1/p/11305546.html</a></p><h3 id="Valotile底层"><a href="#Valotile底层" class="headerlink" title="Valotile底层"></a><a href="https://www.cnblogs.com/xyang/p/8656034.html" target="_blank" rel="noopener">Valotile底层</a></h3><h3 id="reentrentlock底层原理"><a href="#reentrentlock底层原理" class="headerlink" title="reentrentlock底层原理"></a><a href="https://blog.csdn.net/BlackPlus28/article/details/82764772" target="_blank" rel="noopener">reentrentlock底层原理</a></h3><p><a href="https://www.cnblogs.com/zhangfengshi/p/9203191.html" target="_blank" rel="noopener">ReentrantLock实现原理</a>  </p><h3 id="联合索引最左前缀"><a href="#联合索引最左前缀" class="headerlink" title="联合索引最左前缀"></a><a href="https://www.cnblogs.com/wezheng/p/8399305.html" target="_blank" rel="noopener">联合索引最左前缀</a></h3><h3 id="select，poll，epoll优缺点及比较"><a href="#select，poll，epoll优缺点及比较" class="headerlink" title="select，poll，epoll优缺点及比较"></a><a href="https://www.cnblogs.com/llguanli/p/8721103.html" target="_blank" rel="noopener">select，poll，epoll优缺点及比较</a></h3><ul><li>epoll把用户注冊的文件描写叙述符和事件放到内核当中的事件表中。提供了一个独立的系统调用epoll_ctl来管理用户的事件，并且epoll<strong>採用回调的方式</strong>。一旦有注冊的<strong>文件描写叙述符就绪</strong>，讲<strong>触发回调函数</strong>，该回调函数将<strong>就绪的文件描写叙述符和事件</strong>复制到<strong>用户空间events</strong>所管理的内存。这样应用程序索引就绪文件的时间复杂度达到O(1)。<br><img src="https://img-blog.csdn.net/20160422143642896" alt>  </li></ul><h3 id="select，poll，epoll优缺点及比较2"><a href="#select，poll，epoll优缺点及比较2" class="headerlink" title="select，poll，epoll优缺点及比较2"></a><a href="https://blog.csdn.net/mmbbz/article/details/70303951" target="_blank" rel="noopener">select，poll，epoll优缺点及比较2</a></h3><h3 id="Websocket原理"><a href="#Websocket原理" class="headerlink" title="Websocket原理"></a><a href="https://blog.csdn.net/yinqingwang/article/details/52565133" target="_blank" rel="noopener">Websocket原理</a></h3><h3 id="Linux命令统计实现找出日志文件中监听请求数前十多的数"><a href="#Linux命令统计实现找出日志文件中监听请求数前十多的数" class="headerlink" title="Linux命令统计实现找出日志文件中监听请求数前十多的数?"></a>Linux命令统计实现找出日志文件中监听请求数前十多的数?</h3><p><a href="https://www.cnblogs.com/zhaijing/p/9767285.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhaijing/p/9767285.html</a><br><a href="https://blog.csdn.net/ahjxhy2010/article/details/50542664" target="_blank" rel="noopener">https://blog.csdn.net/ahjxhy2010/article/details/50542664</a>   </p><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h3 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h3><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p><ul><li><strong>底层数据结构</strong>： JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li><li><strong>实现线程安全的方式（重要）</strong>： ① 在JDK1.7的时候，ConcurrentHashMap（分段锁） 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 <strong>Node 数组+链表+红黑树</strong>的数据结构来实现，并发控制使用 <strong>synchronized 和 CAS </strong>来操作。   （JDK1.6以后 对 synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；②<strong> Hashtable(同一把锁)</strong>:使用 <strong>synchronized</strong> 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。  <h3 id="线程安全的集合类的实现原理汇总："><a href="#线程安全的集合类的实现原理汇总：" class="headerlink" title="线程安全的集合类的实现原理汇总："></a>线程安全的集合类的实现原理汇总：</h3></li><li>vector大部分方法包含关键字synchronized</li><li>concurrenthashmap利用synchronized+CAS保证线程安全，同时hashentry中的value值用valotile关键字修饰</li><li>copyonwriteList利用Reentrantlock对写加锁  </li></ul><h3 id="myBatis-Spring-SpringMVC框架面试题整理"><a href="#myBatis-Spring-SpringMVC框架面试题整理" class="headerlink" title="myBatis+Spring+SpringMVC框架面试题整理"></a>myBatis+Spring+SpringMVC框架面试题整理</h3><p><a href="https://blog.csdn.net/qq_41541619/article/details/82459873" target="_blank" rel="noopener">myBatis+Spring+SpringMVC框架面试题整理(一)</a><br><a href="https://blog.csdn.net/qq_41541619/article/details/82459965" target="_blank" rel="noopener">myBatis+Spring+SpringMVC框架面试题整理(二)</a>  </p><p>mybatis初始化要经过简单的以下几步：</p><pre><code>1. 调用SqlSessionFactoryBuilder对象的build(inputStream)方法；2. SqlSessionFactoryBuilder会根据输入流inputStream等信息创建XMLConfigBuilder对象;3. SqlSessionFactoryBuilder调用XMLConfigBuilder对象的parse()方法；4. XMLConfigBuilder对象返回Configuration对象；5. SqlSessionFactoryBuilder根据Configuration对象创建一个DefaultSessionFactory对象；6. SqlSessionFactoryBuilder返回 DefaultSessionFactory对象给Client，供Client使用。</code></pre><p>mybatis执行流程</p><ol><li>加载配置文件并初始化(SqlSession)<br>配置文件来源于两个地方，一个是配置文件(主配置文件conf.xml,mapper文件*.xml)，一个是java代码中的注释，将sql的配置信息加载成为一个mappedstatement对象，存储在内存之中（包括传入参数的映射配置，结果映射配置，执行的sql语句）。</li><li>接收调用请求<br>调用mybatis提供的api，传入的参数为sql的id（有namespase和具体sql的id组成）和sql语句的参数对象，mybatis将调用请求交给请求处理层。</li><li>处理请求<br>根据sql的id找到对应的mappedstatament对象。<br>根据传入参数解析mappedstatement对象，得到最终要执行的sql。<br>获取数据库连接，执行sql，得到执行结果<br>Mappedstatement对象中的结果映射对执行结果进行转换处理，并得到最终的处理结果。<br>释放连接资源</li><li>返回处理结果</li></ol><h3 id="JAVA中常用的一个编程技术：双重检查锁定，我们知道Object的wait和notify需要写在synchronized中，双重检查锁定就是除了在一开始判断item是否为null外，在synchonized内部再判断一次。"><a href="#JAVA中常用的一个编程技术：双重检查锁定，我们知道Object的wait和notify需要写在synchronized中，双重检查锁定就是除了在一开始判断item是否为null外，在synchonized内部再判断一次。" class="headerlink" title="JAVA中常用的一个编程技术：双重检查锁定，我们知道Object的wait和notify需要写在synchronized中，双重检查锁定就是除了在一开始判断item是否为null外，在synchonized内部再判断一次。"></a>JAVA中常用的一个编程技术：双重检查锁定，我们知道Object的wait和notify需要写在synchronized中，双重检查锁定就是除了在一开始判断item是否为null外，在synchonized内部再判断一次。</h3><h3 id="concurrrenthashmap原理"><a href="#concurrrenthashmap原理" class="headerlink" title="concurrrenthashmap原理"></a>concurrrenthashmap原理</h3><p>JDK8中ConcurrentHashMap参考了JDK8 HashMap的实现，采用了数组+链表+红黑树的实现方式来设计，内部大量采用CAS操作，这里我简要介绍下CAS。<br>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存地址里面的值和A的值是一样的，那么就将内存里面的值更新成B。CAS是通过无限循环来获取数据的，若果在第一轮循环中，a线程获取地址里面的值被b线程修改了，那么a线程需要<strong>自旋</strong>，到下次循环才有可能机会执行。  </p><h4 id="JDK8中彻底放弃了Segment转而采用的是Node，其设计思想也不再是JDK1-7中的分段锁思想。"><a href="#JDK8中彻底放弃了Segment转而采用的是Node，其设计思想也不再是JDK1-7中的分段锁思想。" class="headerlink" title="JDK8中彻底放弃了Segment转而采用的是Node，其设计思想也不再是JDK1.7中的分段锁思想。"></a>JDK8中彻底放弃了Segment转而采用的是Node，其设计思想也不再是JDK1.7中的分段锁思想。</h4><p>Node：保存key，value及key的hash值的数据结构。其中<strong>value和next都用volatile</strong>修饰，保证并发的<strong>可见性</strong>。</p><pre><code>&lt;strong&gt;class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {final int hash;final K key;volatile V val;volatile Node&lt;K,V&gt; next;//... 省略部分代码}   </code></pre><p>Java8 ConcurrentHashMap结构基本上和Java8的HashMap一样，不过保证线程安全性。  </p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>从JDK1.7版本的<strong>ReentrantLock+Segment+HashEntry</strong>，到JDK1.8版本中<strong>synchronized+CAS+HashEntry+红黑树</strong>。</p><ul><li>1.数据结构：取消了Segment分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。</li><li>2.保证线程安全机制：JDK1.7采用segment的分段锁机制实现线程安全，其中<strong>segment继承自ReentrantLock</strong>。<strong>JDK1.8</strong>采用<strong>CAS+Synchronized保证线程安全</strong>。</li><li>3.锁的粒度：原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁（Node）。</li><li>4.链表转化为红黑树:定位结点的hash算法简化会带来弊端,Hash冲突加剧,因此在链表节点数量大于<strong>8</strong>时，会将链表转化为红黑树进行存储。<br>5.查询时间复杂度：从原来的遍历链表O(n)，变成遍历红黑树<strong>O(logN)</strong>。  <h3 id="java-finalize方法总结、GC执行finalize的过程"><a href="#java-finalize方法总结、GC执行finalize的过程" class="headerlink" title="java finalize方法总结、GC执行finalize的过程"></a>java finalize方法总结、GC执行finalize的过程</h3><h4 id="finalize的作用"><a href="#finalize的作用" class="headerlink" title="finalize的作用"></a>finalize的作用</h4></li></ul><ul><li>finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。</li><li>finalize()与C++中的析构函数不是对应的。C++中的析构函数调用的时机是确定的（对象离开作用域或delete掉），但Java中的finalize的调用具有<strong>不确定性</strong></li><li>不建议用finalize方法完成“非内存资源”的清理工作，但建议用于：① 清理本地对象(通过JNI创建的对象)；② 作为确保某些非内存资源(如Socket、文件等)释放的一个补充：在finalize方法中显式调用其他资源释放方法。其原因可见下文[finalize的问题]  </li></ul><h4 id="finalize的问题"><a href="#finalize的问题" class="headerlink" title="finalize的问题"></a>finalize的问题</h4><ul><li>一些与finalize相关的方法，由于一些致命的缺陷，已经被废弃了，如System.runFinalizersOnExit()方法、Runtime.runFinalizersOnExit()方法</li><li>System.gc()与System.runFinalization()方法增加了finalize方法执行的机会，但不可盲目依赖它们</li><li>Java语言规范并不保证finalize方法会被及时地执行、而且根本不会保证它们会被执行</li><li>finalize方法可能会带来性能问题。因为JVM通常在单独的低优先级线程中完成finalize的执行</li><li>对象再生问题：finalize方法中，可将待回收对象赋值给GC Roots可达的对象引用，从而达到对象再生的目的</li><li>finalize方法<strong>至多由GC执行一次</strong>(用户当然可以手动调用对象的finalize方法，但并不影响GC对finalize的行为)  </li></ul><h4 id="finalize的执行过程-生命周期"><a href="#finalize的执行过程-生命周期" class="headerlink" title="finalize的执行过程(生命周期)"></a>finalize的执行过程(生命周期)</h4><ul><li>(1) 首先，大致描述一下finalize流程：当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入<strong>F-Queue</strong>队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。</li><li>(2) 具体的finalize流程：<br>对象可由两种状态，涉及到两类状态空间，一是终结状态空间 F = {unfinalized, finalizable, finalized}；二是可达状态空间 R = {reachable, finalizer-reachable, unreachable}。各状态含义如下：<ul><li>unfinalized: 新建对象会先进入此状态，GC并未准备执行其finalize方法，因为该对象是可达的</li><li>finalizable: 表示GC可对该对象执行finalize方法，GC已检测到该对象不可达。正如前面所述，GC通过F-Queue队列和一专用线程完成finalize的执行</li><li>finalized: 表示GC已经对该对象执行过finalize方法</li><li>reachable: 表示GC Roots引用可达</li><li>finalizer-reachable(f-reachable)：表示不是reachable，但可通过某个finalizable对象可达</li><li>unreachable：对象不可通过上面两种途径可达<br><img src="http://img.blog.csdn.net/20131006163937765" alt>  </li></ul></li><li><p>变迁说明：   </p><ul><li>新建对象首先处于[reachable, unfinalized]状态(A)</li><li>随着程序的运行，一些引用关系会消失，导致状态变迁，从reachable状态变迁到f-reachable(B, C, D)或unreachable(E, F)状态</li><li>若JVM检测到处于unfinalized状态的对象变成f-reachable或unreachable，JVM会将其标记为finalizable状态(G,H)。若对象原处于[unreachable, unfinalized]状态，则同时将其标记为f-reachable(H)。</li><li>在某个时刻，JVM取出某个finalizable对象，将其标记为finalized并在某个线程中执行其finalize方法。由于是在活动线程中引用了该对象，该对象将变迁到(reachable, finalized)状态(K或J)。该动作将影响某些其他对象从f-reachable状态重新回到reachable状态(L, M, N)</li><li>处于finalizable状态的对象不能同时是unreahable的，由第4点可知，将对象finalizable对象标记为finalized时会由某个线程执行该对象的finalize方法，致使其变成reachable。这也是图中只有八个状态点的原因</li><li>程序员手动调用finalize方法并不会影响到上述内部标记的变化，因此JVM只会至多调用finalize一次，即使该对象“复活”也是如此。程序员手动调用多少次不影响JVM的行为</li><li>若JVM检测到finalized状态的对象变成unreachable，回收其内存(I)</li><li>若对象并未覆盖finalize方法，JVM会进行优化，直接回收对象（O）</li><li><p>注：System.runFinalizersOnExit()等方法可以使对象即使处于reachable状态，JVM仍对其执行finalize方法</p><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><p>public class GC {  </p><p>public static GC SAVE_HOOK = null;  </p><p>public static void main(String[] args) throws InterruptedException {</p><pre><code>// 新建对象，因为SAVE_HOOK指向这个对象，对象此时的状态是(reachable,unfinalized)SAVE_HOOK = new GC();  //将SAVE_HOOK设置成null，此时刚才创建的对象就不可达了，因为没有句柄再指向它了，对象此时状态是(unreachable，unfinalized)SAVE_HOOK = null;  //强制系统执行垃圾回收，系统发现刚才创建的对象处于unreachable状态，并检测到这个对象的类覆盖了finalize方法，因此把这个对象放入F-Queue队列，由低优先级线程执行它的finalize方法，此时对象的状态变成(unreachable, finalizable)或者是(finalizer-reachable,finalizable)System.gc();  // sleep，目的是给低优先级线程从F-Queue队列取出对象并执行其finalize方法提供机会。在执行完对象的finalize方法中的super.finalize()时，对象的状态变成(unreachable,finalized)状态，但接下来在finalize方法中又执行了SAVE_HOOK = this;这句话，又有句柄指向这个对象了，对象又可达了。因此对象的状态又变成了(reachable, finalized)状态。Thread.sleep(500); // 这里楼主说对象处于(reachable,finalized)状态应该是合理的。对象的finalized方法被执行了，因此是finalized状态。又因为在finalize方法是执行了SAVE_HOOK=this这句话，本来是unreachable的对象，又变成reachable了。 if (null != SAVE_HOOK) { //此时对象应该处于(reachable, finalized)状态      // 这句话会输出，注意对象由unreachable，经过finalize复活了。    System.out.println(&quot;Yes , I am still alive&quot;);  } else {      System.out.println(&quot;No , I am dead&quot;);  }  // 再一次将SAVE_HOOK放空，此时刚才复活的对象，状态变成(unreachable,finalized)SAVE_HOOK = null;  // 再一次强制系统回收垃圾，此时系统发现对象不可达，虽然覆盖了finalize方法，但已经执行过了，因此直接回收。System.gc();  // 为系统回收垃圾提供机会Thread.sleep(500);  if (null != SAVE_HOOK) {      // 这句话不会输出，因为对象已经彻底消失了。    System.out.println(&quot;Yes , I am still alive&quot;);  } else {      System.out.println(&quot;No , I am dead&quot;);  }  </code></pre><p>}  </p><p>@Override<br>protected void finalize() throws Throwable {  </p><pre><code>super.finalize();  System.out.println(&quot;execute method finalize()&quot;);  </code></pre><p>   // 这句话让对象的状态由unreachable变成reachable，就是对象复活</p><pre><code>SAVE_HOOK = this;  </code></pre><p>}<br>}   </p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;java常见面试汇总&lt;br&gt;=&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/SnailClimb/JavaGuide/tree/master/docs/java&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;参考链接：javagui
      
    
    </summary>
    
    
      <category term="知识点汇总" scheme="http://yoursite.com/categories/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    
    
      <category term="知识点汇总" scheme="http://yoursite.com/tags/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>blog</title>
    <link href="http://yoursite.com/2019/10/01/blog/"/>
    <id>http://yoursite.com/2019/10/01/blog/</id>
    <published>2019-10-01T10:38:36.000Z</published>
    <updated>2019-10-01T10:40:49.626Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="test" scheme="http://yoursite.com/categories/test/"/>
    
    
      <category term="test" scheme="http://yoursite.com/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/10/01/hello-world/"/>
    <id>http://yoursite.com/2019/10/01/hello-world/</id>
    <published>2019-10-01T07:15:08.159Z</published>
    <updated>2019-10-01T07:15:08.159Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
